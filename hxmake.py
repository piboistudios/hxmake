# Generated by Haxe 4.0.5
# coding: utf-8
import sys

import math as python_lib_Math
import math as Math
import sys as python_lib_Sys
import builtins as python_lib_Builtins
import functools as python_lib_Functools
try:
    import msvcrt as python_lib_Msvcrt
except:
    pass
import random as python_lib_Random
import re as python_lib_Re
import subprocess as python_lib_Subprocess
try:
    import termios as python_lib_Termios
except:
    pass
import timeit as python_lib_Timeit
try:
    import tty as python_lib_Tty
except:
    pass
from datetime import datetime as python_lib_datetime_Datetime
from datetime import timezone as python_lib_datetime_Timezone
from io import BufferedReader as python_lib_io_BufferedReader
from io import BufferedWriter as python_lib_io_BufferedWriter
from io import StringIO as python_lib_io_StringIO
from io import TextIOWrapper as python_lib_io_TextIOWrapper
from subprocess import Popen as python_lib_subprocess_Popen


class _hx_AnonObject:
    _hx_disable_getattr = False
    def __init__(self, fields):
        self.__dict__ = fields
    def __repr__(self):
        return repr(self.__dict__)
    def __getattr__(self, name):
        if (self._hx_disable_getattr):
            raise AttributeError('field does not exist')
        else:
            return None
    def _hx_hasattr(self,field):
        self._hx_disable_getattr = True
        try:
            getattr(self, field)
            self._hx_disable_getattr = False
            return True
        except AttributeError:
            self._hx_disable_getattr = False
            return False



class Enum:
    _hx_class_name = "Enum"
    _hx_is_interface = "False"
    __slots__ = ("tag", "index", "params")
    _hx_fields = ["tag", "index", "params"]
    _hx_methods = ["__str__"]

    def __init__(self,tag,index,params):
        self.tag = tag
        self.index = index
        self.params = params

    def __str__(self):
        if (self.params is None):
            return self.tag
        else:
            return self.tag + '(' + (', '.join(str(v) for v in self.params)) + ')'



class Date:
    _hx_class_name = "Date"
    _hx_is_interface = "False"
    __slots__ = ("date", "dateUTC")
    _hx_fields = ["date", "dateUTC"]
    _hx_statics = ["fromTime", "makeLocal"]

    def __init__(self,year,month,day,hour,_hx_min,sec):
        self.dateUTC = None
        if (year < python_lib_datetime_Datetime.min.year):
            year = python_lib_datetime_Datetime.min.year
        if (day == 0):
            day = 1
        self.date = Date.makeLocal(python_lib_datetime_Datetime(year,(month + 1),day,hour,_hx_min,sec,0))
        self.dateUTC = self.date.astimezone(python_lib_datetime_Timezone.utc)

    @staticmethod
    def fromTime(t):
        d = Date(2000,0,1,0,0,0)
        d.date = Date.makeLocal(python_lib_datetime_Datetime.fromtimestamp((t / 1000.0)))
        d.dateUTC = d.date.astimezone(python_lib_datetime_Timezone.utc)
        return d

    @staticmethod
    def makeLocal(date):
        try:
            return date.astimezone()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            tzinfo = python_lib_datetime_Datetime.now(python_lib_datetime_Timezone.utc).astimezone().tzinfo
            return date.replace(**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'tzinfo': tzinfo})))



class EReg:
    _hx_class_name = "EReg"
    _hx_is_interface = "False"
    __slots__ = ("pattern", "matchObj", "_hx_global")
    _hx_fields = ["pattern", "matchObj", "global"]
    _hx_methods = ["split"]

    def __init__(self,r,opt):
        self.matchObj = None
        self._hx_global = False
        options = 0
        _g = 0
        _g1 = len(opt)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = (-1 if ((i >= len(opt))) else ord(opt[i]))
            if (c == 109):
                options = (options | python_lib_Re.M)
            if (c == 105):
                options = (options | python_lib_Re.I)
            if (c == 115):
                options = (options | python_lib_Re.S)
            if (c == 117):
                options = (options | python_lib_Re.U)
            if (c == 103):
                self._hx_global = True
        self.pattern = python_lib_Re.compile(r,options)

    def split(self,s):
        if self._hx_global:
            ret = []
            lastEnd = 0
            x = python_HaxeIterator(python_lib_Re.finditer(self.pattern,s))
            while x.hasNext():
                x1 = x.next()
                x2 = HxString.substring(s,lastEnd,x1.start())
                ret.append(x2)
                lastEnd = x1.end()
            x3 = HxString.substr(s,lastEnd,None)
            ret.append(x3)
            return ret
        else:
            self.matchObj = python_lib_Re.search(self.pattern,s)
            if (self.matchObj is None):
                return [s]
            else:
                return [HxString.substring(s,0,self.matchObj.start()), HxString.substr(s,self.matchObj.end(),None)]



class Reflect:
    _hx_class_name = "Reflect"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["field", "setField"]

    @staticmethod
    def field(o,field):
        return python_Boot.field(o,field)

    @staticmethod
    def setField(o,field,value):
        setattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)),value)


class Std:
    _hx_class_name = "Std"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["downcast", "string", "parseInt", "shortenPossibleNumber", "parseFloat"]

    @staticmethod
    def downcast(value,c):
        try:
            tmp = None
            if (not isinstance(value,c)):
                if c._hx_is_interface:
                    cls = c
                    loop = None
                    def _hx_local_1(intf):
                        f = (intf._hx_interfaces if (hasattr(intf,"_hx_interfaces")) else [])
                        if (f is not None):
                            _g = 0
                            while (_g < len(f)):
                                i = (f[_g] if _g >= 0 and _g < len(f) else None)
                                _g = (_g + 1)
                                if (i == cls):
                                    return True
                                else:
                                    l = loop(i)
                                    if l:
                                        return True
                            return False
                        else:
                            return False
                    loop = _hx_local_1
                    currentClass = value.__class__
                    result = False
                    while (currentClass is not None):
                        if loop(currentClass):
                            result = True
                            break
                        currentClass = python_Boot.getSuperClass(currentClass)
                    tmp = result
                else:
                    tmp = False
            else:
                tmp = True
            if tmp:
                return value
            else:
                return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return None

    @staticmethod
    def string(s):
        return python_Boot.toString1(s,"")

    @staticmethod
    def parseInt(x):
        if (x is None):
            return None
        try:
            return int(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            base = 10
            _hx_len = len(x)
            foundCount = 0
            sign = 0
            firstDigitIndex = 0
            lastDigitIndex = -1
            previous = 0
            _g = 0
            _g1 = _hx_len
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                c = (-1 if ((i >= len(x))) else ord(x[i]))
                if (((c > 8) and ((c < 14))) or ((c == 32))):
                    if (foundCount > 0):
                        return None
                    continue
                else:
                    c1 = c
                    if (c1 == 43):
                        if (foundCount == 0):
                            sign = 1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 45):
                        if (foundCount == 0):
                            sign = -1
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (c1 == 48):
                        if (not (((foundCount == 0) or (((foundCount == 1) and ((sign != 0))))))):
                            if (not (((48 <= c) and ((c <= 57))))):
                                if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                    break
                    elif ((c1 == 120) or ((c1 == 88))):
                        if ((previous == 48) and ((((foundCount == 1) and ((sign == 0))) or (((foundCount == 2) and ((sign != 0))))))):
                            base = 16
                        elif (not (((48 <= c) and ((c <= 57))))):
                            if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                                break
                    elif (not (((48 <= c) and ((c <= 57))))):
                        if (not (((base == 16) and ((((97 <= c) and ((c <= 122))) or (((65 <= c) and ((c <= 90))))))))):
                            break
                if (((foundCount == 0) and ((sign == 0))) or (((foundCount == 1) and ((sign != 0))))):
                    firstDigitIndex = i
                foundCount = (foundCount + 1)
                lastDigitIndex = i
                previous = c
            if (firstDigitIndex <= lastDigitIndex):
                digits = HxString.substring(x,firstDigitIndex,(lastDigitIndex + 1))
                try:
                    return (((-1 if ((sign == -1)) else 1)) * int(digits,base))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e1 = _hx_e1
                    return None
            return None

    @staticmethod
    def shortenPossibleNumber(x):
        r = ""
        _g = 0
        _g1 = len(x)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            c = ("" if (((i < 0) or ((i >= len(x))))) else x[i])
            _g2 = HxString.charCodeAt(c,0)
            if (_g2 is None):
                break
            else:
                _g3 = _g2
                if (((((((((((_g3 == 57) or ((_g3 == 56))) or ((_g3 == 55))) or ((_g3 == 54))) or ((_g3 == 53))) or ((_g3 == 52))) or ((_g3 == 51))) or ((_g3 == 50))) or ((_g3 == 49))) or ((_g3 == 48))) or ((_g3 == 46))):
                    r = (("null" if r is None else r) + ("null" if c is None else c))
                else:
                    break
        return r

    @staticmethod
    def parseFloat(x):
        try:
            return float(x)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            if (x is not None):
                r1 = Std.shortenPossibleNumber(x)
                if (r1 != x):
                    return Std.parseFloat(r1)
            return Math.NaN


class _String_String_Impl_:
    _hx_class_name = "_String.String_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromCharCode"]

    @staticmethod
    def fromCharCode(code):
        return "".join(map(chr,[code]))


class StringTools:
    _hx_class_name = "StringTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isSpace", "ltrim", "rtrim", "trim"]

    @staticmethod
    def isSpace(s,pos):
        if (((len(s) == 0) or ((pos < 0))) or ((pos >= len(s)))):
            return False
        c = HxString.charCodeAt(s,pos)
        if (not (((c > 8) and ((c < 14))))):
            return (c == 32)
        else:
            return True

    @staticmethod
    def ltrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,r)):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,r,(l - r))
        else:
            return s

    @staticmethod
    def rtrim(s):
        l = len(s)
        r = 0
        while ((r < l) and StringTools.isSpace(s,((l - r) - 1))):
            r = (r + 1)
        if (r > 0):
            return HxString.substr(s,0,(l - r))
        else:
            return s

    @staticmethod
    def trim(s):
        return StringTools.ltrim(StringTools.rtrim(s))


class haxe_IMap:
    _hx_class_name = "haxe.IMap"
    _hx_is_interface = "True"
    __slots__ = ()


class python_HaxeIterator:
    _hx_class_name = "python.HaxeIterator"
    _hx_is_interface = "False"
    __slots__ = ("it", "x", "has", "checked")
    _hx_fields = ["it", "x", "has", "checked"]
    _hx_methods = ["next", "hasNext"]

    def __init__(self,it):
        self.checked = False
        self.has = False
        self.x = None
        self.it = it

    def next(self):
        if (not self.checked):
            self.hasNext()
        self.checked = False
        return self.x

    def hasNext(self):
        if (not self.checked):
            try:
                self.x = self.it.__next__()
                self.has = True
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                if isinstance(_hx_e1, StopIteration):
                    s = _hx_e1
                    self.has = False
                    self.x = None
                else:
                    raise _hx_e
            self.checked = True
        return self.has



class Sys:
    _hx_class_name = "Sys"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exit", "args", "systemName", "command", "getChar", "stdin"]

    @staticmethod
    def exit(code):
        python_lib_Sys.exit(code)

    @staticmethod
    def args():
        argv = python_lib_Sys.argv
        return argv[1:None]

    @staticmethod
    def systemName():
        _g = python_lib_Sys.platform
        x = _g
        if x.startswith("linux"):
            return "Linux"
        else:
            _g1 = _g
            _hx_local_0 = len(_g1)
            if (_hx_local_0 == 5):
                if (_g1 == "win32"):
                    return "Windows"
                else:
                    raise _HxException("not supported platform")
            elif (_hx_local_0 == 6):
                if (_g1 == "cygwin"):
                    return "Windows"
                elif (_g1 == "darwin"):
                    return "Mac"
                else:
                    raise _HxException("not supported platform")
            else:
                raise _HxException("not supported platform")

    @staticmethod
    def command(cmd,args = None):
        if (args is None):
            return python_lib_Subprocess.call(cmd,**python__KwArgs_KwArgs_Impl_.fromT(_hx_AnonObject({'shell': True})))
        else:
            return python_lib_Subprocess.call(([cmd] + args))

    @staticmethod
    def getChar(echo):
        ch = None
        _g = Sys.systemName()
        _g1 = _g
        _hx_local_0 = len(_g1)
        if (_hx_local_0 == 5):
            if (_g1 == "Linux"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_1():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_1
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 3):
            if (_g1 == "Mac"):
                fd = python_lib_Sys.stdin.fileno()
                old = python_lib_Termios.tcgetattr(fd)
                fileNo = fd
                when = python_lib_Termios.TCSADRAIN
                settings = old
                def _hx_local_2():
                    python_lib_Termios.tcsetattr(fileNo,when,settings)
                restore = _hx_local_2
                try:
                    python_lib_Tty.setraw(fd)
                    x = python_lib_Sys.stdin.read(1)
                    restore()
                    ch = HxString.charCodeAt(x,0)
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    restore()
                    raise _HxException(e)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        elif (_hx_local_0 == 7):
            if (_g1 == "Windows"):
                ch = HxString.charCodeAt(python_lib_Msvcrt.getwch(),0)
            else:
                x1 = _g
                raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        else:
            x1 = _g
            raise _HxException((("platform " + ("null" if x1 is None else x1)) + " not supported"))
        if echo:
            python_Lib.printString(Std.string("".join(map(chr,[ch]))))
        return ch

    @staticmethod
    def stdin():
        return python_io_IoTools.createFileInputFromText(python_lib_Sys.stdin)

class haxe_StackItem(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.StackItem"

    @staticmethod
    def Module(m):
        return haxe_StackItem("Module", 1, (m,))

    @staticmethod
    def FilePos(s,file,line,column = None):
        return haxe_StackItem("FilePos", 2, (s,file,line,column))

    @staticmethod
    def Method(classname,method):
        return haxe_StackItem("Method", 3, (classname,method))

    @staticmethod
    def LocalFunction(v = None):
        return haxe_StackItem("LocalFunction", 4, (v,))
haxe_StackItem.CFunction = haxe_StackItem("CFunction", 0, ())


class haxe_EntryPoint:
    _hx_class_name = "haxe.EntryPoint"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "threadCount", "processEvents", "run"]

    @staticmethod
    def processEvents():
        while True:
            _this = haxe_EntryPoint.pending
            f = (None if ((len(_this) == 0)) else _this.pop(0))
            if (f is None):
                break
            f()
        time = haxe_MainLoop.tick()
        if ((not haxe_MainLoop.hasEvents()) and ((haxe_EntryPoint.threadCount == 0))):
            return -1
        return time

    @staticmethod
    def run():
        while True:
            nextTick = haxe_EntryPoint.processEvents()
            if (nextTick < 0):
                break
            tmp = (nextTick > 0)


class haxe_MainEvent:
    _hx_class_name = "haxe.MainEvent"
    _hx_is_interface = "False"
    __slots__ = ("f", "prev", "next", "isBlocking", "nextRun", "priority")
    _hx_fields = ["f", "prev", "next", "isBlocking", "nextRun", "priority"]
    _hx_methods = ["delay", "stop"]

    def __init__(self,f,p):
        self.next = None
        self.prev = None
        self.isBlocking = True
        self.f = f
        self.priority = p
        self.nextRun = Math.NEGATIVE_INFINITY

    def delay(self,t):
        self.nextRun = (Math.NEGATIVE_INFINITY if ((t is None)) else (python_lib_Timeit.default_timer() + t))

    def stop(self):
        if (self.f is None):
            return
        self.f = None
        self.nextRun = Math.NEGATIVE_INFINITY
        if (self.prev is None):
            haxe_MainLoop.pending = self.next
        else:
            self.prev.next = self.next
        if (self.next is not None):
            self.next.prev = self.prev



class haxe_MainLoop:
    _hx_class_name = "haxe.MainLoop"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["pending", "hasEvents", "add", "sortEvents", "tick"]
    pending = None
    threadCount = None

    @staticmethod
    def hasEvents():
        p = haxe_MainLoop.pending
        while (p is not None):
            if p.isBlocking:
                return True
            p = p.next
        return False

    @staticmethod
    def add(f,priority = None):
        if (priority is None):
            priority = 0
        if (f is None):
            raise _HxException("Event function is null")
        e = haxe_MainEvent(f,priority)
        head = haxe_MainLoop.pending
        if (head is not None):
            head.prev = e
        e.next = head
        haxe_MainLoop.pending = e
        return e

    @staticmethod
    def sortEvents():
        _hx_list = haxe_MainLoop.pending
        if (_hx_list is None):
            return
        insize = 1
        nmerges = None
        psize = 0
        qsize = 0
        p = None
        q = None
        e = None
        tail = None
        while True:
            p = _hx_list
            _hx_list = None
            tail = None
            nmerges = 0
            while (p is not None):
                nmerges = (nmerges + 1)
                q = p
                psize = 0
                _g = 0
                _g1 = insize
                while (_g < _g1):
                    i = _g
                    _g = (_g + 1)
                    psize = (psize + 1)
                    q = q.next
                    if (q is None):
                        break
                qsize = insize
                while ((psize > 0) or (((qsize > 0) and ((q is not None))))):
                    if (psize == 0):
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    elif (((qsize == 0) or ((q is None))) or (((p.priority > q.priority) or (((p.priority == q.priority) and ((p.nextRun <= q.nextRun))))))):
                        e = p
                        p = p.next
                        psize = (psize - 1)
                    else:
                        e = q
                        q = q.next
                        qsize = (qsize - 1)
                    if (tail is not None):
                        tail.next = e
                    else:
                        _hx_list = e
                    e.prev = tail
                    tail = e
                p = q
            tail.next = None
            if (nmerges <= 1):
                break
            insize = (insize * 2)
        _hx_list.prev = None
        haxe_MainLoop.pending = _hx_list

    @staticmethod
    def tick():
        haxe_MainLoop.sortEvents()
        e = haxe_MainLoop.pending
        now = python_lib_Timeit.default_timer()
        wait = 1e9
        while (e is not None):
            next = e.next
            wt = (e.nextRun - now)
            if (wt <= 0):
                wait = 0
                if (e.f is not None):
                    e.f()
            elif (wait > wt):
                wait = wt
            e = next
        return wait


class haxe_Timer:
    _hx_class_name = "haxe.Timer"
    _hx_is_interface = "False"
    _hx_fields = ["event"]
    _hx_methods = ["stop", "run"]
    _hx_statics = ["delay"]

    def __init__(self,time_ms):
        self.event = None
        _gthis = self
        dt = (time_ms / 1000)
        def _hx_local_2():
            _hx_local_0 = _gthis.event
            _hx_local_1 = _hx_local_0.nextRun
            _hx_local_0.nextRun = (_hx_local_1 + dt)
            _hx_local_0.nextRun
            _gthis.run()
        self.event = haxe_MainLoop.add(_hx_local_2)
        self.event.delay(dt)

    def stop(self):
        if (self.event is not None):
            self.event.stop()
            self.event = None

    def run(self):
        pass

    @staticmethod
    def delay(f,time_ms):
        t = haxe_Timer(time_ms)
        def _hx_local_0():
            t.stop()
            f()
        t.run = _hx_local_0
        return t


class haxe_ds_Either(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Either"

    @staticmethod
    def Left(v):
        return haxe_ds_Either("Left", 0, (v,))

    @staticmethod
    def Right(v):
        return haxe_ds_Either("Right", 1, (v,))


class haxe_ds_ObjectMap:
    _hx_class_name = "haxe.ds.ObjectMap"
    _hx_is_interface = "False"
    __slots__ = ("h",)
    _hx_fields = ["h"]
    _hx_interfaces = [haxe_IMap]

    def __init__(self):
        self.h = dict()


class haxe_ds_Option(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.ds.Option"

    @staticmethod
    def Some(v):
        return haxe_ds_Option("Some", 0, (v,))
haxe_ds_Option._hx_None = haxe_ds_Option("None", 1, ())


class haxe_io_Bytes:
    _hx_class_name = "haxe.io.Bytes"
    _hx_is_interface = "False"
    __slots__ = ("length", "b")
    _hx_fields = ["length", "b"]
    _hx_methods = ["getString", "toString"]

    def __init__(self,length,b):
        self.length = length
        self.b = b

    def getString(self,pos,_hx_len,encoding = None):
        tmp = (encoding is None)
        if (((pos < 0) or ((_hx_len < 0))) or (((pos + _hx_len) > self.length))):
            raise _HxException(haxe_io_Error.OutsideBounds)
        return self.b[pos:pos+_hx_len].decode('UTF-8','replace')

    def toString(self):
        return self.getString(0,self.length)



class haxe_io_BytesBuffer:
    _hx_class_name = "haxe.io.BytesBuffer"
    _hx_is_interface = "False"
    __slots__ = ("b",)
    _hx_fields = ["b"]
    _hx_methods = ["getBytes"]

    def __init__(self):
        self.b = bytearray()

    def getBytes(self):
        _hx_bytes = haxe_io_Bytes(len(self.b),self.b)
        self.b = None
        return _hx_bytes


class haxe_io_Encoding(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Encoding"
haxe_io_Encoding.UTF8 = haxe_io_Encoding("UTF8", 0, ())
haxe_io_Encoding.RawNative = haxe_io_Encoding("RawNative", 1, ())


class haxe_io_Eof:
    _hx_class_name = "haxe.io.Eof"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["toString"]

    def __init__(self):
        pass

    def toString(self):
        return "Eof"


class haxe_io_Error(Enum):
    __slots__ = ()
    _hx_class_name = "haxe.io.Error"

    @staticmethod
    def Custom(e):
        return haxe_io_Error("Custom", 3, (e,))
haxe_io_Error.Blocked = haxe_io_Error("Blocked", 0, ())
haxe_io_Error.Overflow = haxe_io_Error("Overflow", 1, ())
haxe_io_Error.OutsideBounds = haxe_io_Error("OutsideBounds", 2, ())


class haxe_io_Input:
    _hx_class_name = "haxe.io.Input"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["readByte", "set_bigEndian", "readLine"]

    def readByte(self):
        raise _HxException("Not implemented")

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b

    def readLine(self):
        buf = haxe_io_BytesBuffer()
        last = None
        s = None
        try:
            while True:
                last = self.readByte()
                if (not ((last != 10))):
                    break
                buf.b.append(last)
            s = buf.getBytes().toString()
            if (HxString.charCodeAt(s,(len(s) - 1)) == 13):
                s = HxString.substr(s,0,-1)
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            if isinstance(_hx_e1, haxe_io_Eof):
                e = _hx_e1
                s = buf.getBytes().toString()
                if (len(s) == 0):
                    raise _HxException(e)
            else:
                raise _hx_e
        return s



class haxe_io_Output:
    _hx_class_name = "haxe.io.Output"
    _hx_is_interface = "False"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]

    def set_bigEndian(self,b):
        self.bigEndian = b
        return b



class haxe_io_Path:
    _hx_class_name = "haxe.io.Path"
    _hx_is_interface = "False"
    __slots__ = ("dir", "file", "ext", "backslash")
    _hx_fields = ["dir", "file", "ext", "backslash"]
    _hx_methods = ["toString"]
    _hx_statics = ["withExtension", "join", "normalize", "addTrailingSlash"]

    def __init__(self,path):
        self.backslash = None
        self.ext = None
        self.file = None
        self.dir = None
        path1 = path
        _hx_local_0 = len(path1)
        if (_hx_local_0 == 1):
            if (path1 == "."):
                self.dir = path
                self.file = ""
                return
        elif (_hx_local_0 == 2):
            if (path1 == ".."):
                self.dir = path
                self.file = ""
                return
        else:
            pass
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex1 = None
        c2 = None
        if (startIndex1 is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i1 = path.rfind("\\", 0, (startIndex1 + 1))
            startLeft1 = (max(0,((startIndex1 + 1) - len("\\"))) if ((i1 == -1)) else (i1 + 1))
            check1 = path.find("\\", startLeft1, len(path))
            c2 = (check1 if (((check1 > i1) and ((check1 <= startIndex1)))) else i1)
        if (c1 < c2):
            self.dir = HxString.substr(path,0,c2)
            path = HxString.substr(path,(c2 + 1),None)
            self.backslash = True
        elif (c2 < c1):
            self.dir = HxString.substr(path,0,c1)
            path = HxString.substr(path,(c1 + 1),None)
        else:
            self.dir = None
        startIndex2 = None
        cp = None
        if (startIndex2 is None):
            cp = path.rfind(".", 0, len(path))
        else:
            i2 = path.rfind(".", 0, (startIndex2 + 1))
            startLeft2 = (max(0,((startIndex2 + 1) - len("."))) if ((i2 == -1)) else (i2 + 1))
            check2 = path.find(".", startLeft2, len(path))
            cp = (check2 if (((check2 > i2) and ((check2 <= startIndex2)))) else i2)
        if (cp != -1):
            self.ext = HxString.substr(path,(cp + 1),None)
            self.file = HxString.substr(path,0,cp)
        else:
            self.ext = None
            self.file = path

    def toString(self):
        return ((HxOverrides.stringOrNull((("" if ((self.dir is None)) else (HxOverrides.stringOrNull(self.dir) + HxOverrides.stringOrNull((("\\" if (self.backslash) else "/"))))))) + HxOverrides.stringOrNull(self.file)) + HxOverrides.stringOrNull((("" if ((self.ext is None)) else ("." + HxOverrides.stringOrNull(self.ext))))))

    @staticmethod
    def withExtension(path,ext):
        s = haxe_io_Path(path)
        s.ext = ext
        return s.toString()

    @staticmethod
    def join(paths):
        def _hx_local_0(s):
            if (s is not None):
                return (s != "")
            else:
                return False
        paths1 = list(filter(_hx_local_0,paths))
        if (len(paths1) == 0):
            return ""
        path = (paths1[0] if 0 < len(paths1) else None)
        _g = 1
        _g1 = len(paths1)
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            path = haxe_io_Path.addTrailingSlash(path)
            path = (("null" if path is None else path) + HxOverrides.stringOrNull((paths1[i] if i >= 0 and i < len(paths1) else None)))
        return haxe_io_Path.normalize(path)

    @staticmethod
    def normalize(path):
        slash = "/"
        _this = path.split("\\")
        path = slash.join([python_Boot.toString1(x1,'') for x1 in _this])
        if (path == slash):
            return slash
        target = []
        _g = 0
        _g1 = (list(path) if ((slash == "")) else path.split(slash))
        while (_g < len(_g1)):
            token = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            if (((token == "..") and ((len(target) > 0))) and ((python_internal_ArrayImpl._get(target, (len(target) - 1)) != ".."))):
                if (len(target) != 0):
                    target.pop()
            elif (token == ""):
                if ((len(target) > 0) or ((HxString.charCodeAt(path,0) == 47))):
                    target.append(token)
            elif (token != "."):
                target.append(token)
        tmp = slash.join([python_Boot.toString1(x1,'') for x1 in target])
        acc_b = python_lib_io_StringIO()
        colon = False
        slashes = False
        _g2 = 0
        _g3 = len(tmp)
        while (_g2 < _g3):
            i = _g2
            _g2 = (_g2 + 1)
            _g21 = (-1 if ((i >= len(tmp))) else ord(tmp[i]))
            _g22 = _g21
            if (_g22 == 47):
                if (not colon):
                    slashes = True
                else:
                    i1 = _g21
                    colon = False
                    if slashes:
                        acc_b.write("/")
                        slashes = False
                    acc_b.write("".join(map(chr,[i1])))
            elif (_g22 == 58):
                acc_b.write(":")
                colon = True
            else:
                i2 = _g21
                colon = False
                if slashes:
                    acc_b.write("/")
                    slashes = False
                acc_b.write("".join(map(chr,[i2])))
        return acc_b.getvalue()

    @staticmethod
    def addTrailingSlash(path):
        if (len(path) == 0):
            return "/"
        startIndex = None
        c1 = None
        if (startIndex is None):
            c1 = path.rfind("/", 0, len(path))
        else:
            i = path.rfind("/", 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len("/"))) if ((i == -1)) else (i + 1))
            check = path.find("/", startLeft, len(path))
            c1 = (check if (((check > i) and ((check <= startIndex)))) else i)
        startIndex1 = None
        c2 = None
        if (startIndex1 is None):
            c2 = path.rfind("\\", 0, len(path))
        else:
            i1 = path.rfind("\\", 0, (startIndex1 + 1))
            startLeft1 = (max(0,((startIndex1 + 1) - len("\\"))) if ((i1 == -1)) else (i1 + 1))
            check1 = path.find("\\", startLeft1, len(path))
            c2 = (check1 if (((check1 > i1) and ((check1 <= startIndex1)))) else i1)
        if (c1 < c2):
            if (c2 != ((len(path) - 1))):
                return (("null" if path is None else path) + "\\")
            else:
                return path
        elif (c1 != ((len(path) - 1))):
            return (("null" if path is None else path) + "/")
        else:
            return path



class hxmake_HxMake:
    _hx_class_name = "hxmake.HxMake"
    _hx_is_interface = "False"
    __slots__ = ("compilerName", "libs", "libPaths", "src", "includePaths", "includes", "output", "defines", "winApi", "verbose", "compiler", "_srcPath", "_outputPath")
    _hx_fields = ["compilerName", "libs", "libPaths", "src", "includePaths", "includes", "output", "defines", "winApi", "verbose", "compiler", "_srcPath", "_outputPath"]
    _hx_methods = ["getCompiler", "run", "get_srcPath", "get_outputPath", "buildObjectBinaries", "buildFinalBinaries"]
    _hx_statics = ["readHxMake", "main"]

    def __init__(self,compiler = None):
        self._outputPath = None
        self._srcPath = None
        self.compiler = None
        self.verbose = None
        self.output = None
        self.src = None
        self.winApi = None
        self.defines = None
        self.includes = None
        self.includePaths = None
        self.libPaths = None
        self.libs = None
        self.compilerName = compiler

    def getCompiler(self,compilerName):
        compilerName1 = compilerName
        _hx_local_0 = len(compilerName1)
        if (_hx_local_0 == 5):
            if (compilerName1 == "clang"):
                return hxmake_compilers_CLang(self)
            else:
                compiler = compilerName
                return hxmake_compilers_GCC(self)
        elif (_hx_local_0 == 3):
            if (compilerName1 == "gcc"):
                return hxmake_compilers_GCC(self)
            else:
                compiler = compilerName
                return hxmake_compilers_GCC(self)
        elif (_hx_local_0 == 2):
            if (compilerName1 == "cl"):
                return hxmake_compilers_CL(self)
            elif (compilerName1 == "cc"):
                return hxmake_compilers_CLang(self)
            else:
                compiler = compilerName
                return hxmake_compilers_GCC(self)
        else:
            compiler = compilerName
            return hxmake_compilers_GCC(self)

    def run(self,rest):
        self.compiler = (self.getCompiler(self.compilerName) if (((self.compilerName is not None) and ((len(self.compilerName) != 0)))) else self.getCompiler("gcc"))
        self.buildObjectBinaries()
        self.buildFinalBinaries()

    def get_srcPath(self):
        if (self._srcPath is None):
            self._srcPath = haxe_io_Path(self.src)
        return self._srcPath

    def get_outputPath(self):
        if (self._outputPath is None):
            self._outputPath = haxe_io_Path(self.output)
        return self._outputPath

    def buildObjectBinaries(self):
        args = self.compiler.getSrcCompilationOptions()
        if (self.includePaths is not None):
            _g = 0
            _g1 = self.includePaths
            while (_g < len(_g1)):
                i = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                includePath = haxe_io_Path(i)
                if (includePath.ext is None):
                    args = (args + self.compiler.getIncludePathOption(includePath))
        if (self.includes is not None):
            _g2 = 0
            _g11 = self.includes
            while (_g2 < len(_g11)):
                i1 = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                include = haxe_io_Path(i1)
                if (include.ext is not None):
                    args = (args + self.compiler.getIncludeOption(include))
        print(str(((("running cmd: " + HxOverrides.stringOrNull(self.compiler.cmd)) + " ") + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args])))))
        hxmake_compilers_CompilerTools.run(self.compiler.cmd,args,self.verbose)

    def buildFinalBinaries(self):
        args = self.compiler.getBinaryCompilationOptions()
        if (self.defines is not None):
            _g = 0
            _g1 = self.defines
            while (_g < len(_g1)):
                define = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
                _g = (_g + 1)
                args = (args + self.compiler.getDefineOption(define))
        args = (args + self.compiler.getOutputOptions())
        if (self.libPaths is not None):
            _g2 = 0
            _g11 = self.libPaths
            while (_g2 < len(_g11)):
                libPath = (_g11[_g2] if _g2 >= 0 and _g2 < len(_g11) else None)
                _g2 = (_g2 + 1)
                libPath1 = haxe_io_Path(libPath)
                if (libPath1.ext is None):
                    args = (args + self.compiler.getLibPathIncludeOption(libPath1))
        if (self.libs is not None):
            _g3 = 0
            _g12 = self.libs
            while (_g3 < len(_g12)):
                _lib = (_g12[_g3] if _g3 >= 0 and _g3 < len(_g12) else None)
                _g3 = (_g3 + 1)
                lib = haxe_io_Path(_lib)
                if (lib.file != ""):
                    args = (args + self.compiler.getLibOption(lib))
        print(str(((("running cmd: " + HxOverrides.stringOrNull(self.compiler.cmd)) + " ") + HxOverrides.stringOrNull(" ".join([python_Boot.toString1(x1,'') for x1 in args])))))
        hxmake_compilers_CompilerTools.run(self.compiler.cmd,args,self.verbose)

    @staticmethod
    def readHxMake():
        def _hx_local_1():
            def _hx_local_0(s):
                return (len(s) != 0)
            return list(filter(_hx_local_0,EReg("(\\s|$)","gi").split(sys_io_File.getContent(python_internal_ArrayImpl._get(Sys.args(), 0)))))
        return _hx_local_1()

    @staticmethod
    def main():
        args = Sys.args()
        if (len(args) == 0):
            print("No HxMakefile provided. Command usage: `hxmake <hxMakefile>")
            Sys.exit(1)
        compiler = (args[1] if 1 < len(args) else None)
        tink_cli_Router0(hxmake_HxMake(compiler),tink_cli_prompt_RetryPrompt(5)).process(hxmake_HxMake.readHxMake()).handle(tink_Cli.exit)



class hxmake_compilers_CompilerBase:
    _hx_class_name = "hxmake.compilers.CompilerBase"
    _hx_is_interface = "False"
    __slots__ = ("cmd", "hxMake")
    _hx_fields = ["cmd", "hxMake"]
    _hx_methods = ["get_outputPath", "get_srcPath"]

    def __init__(self,hxMakefile):
        self.cmd = None
        self.hxMake = hxMakefile

    def get_outputPath(self):
        return self.hxMake.get_outputPath()

    def get_srcPath(self):
        return self.hxMake.get_srcPath()



class hxmake_compilers_Compiler:
    _hx_class_name = "hxmake.compilers.Compiler"
    _hx_is_interface = "True"
    __slots__ = ("cmd",)
    _hx_fields = ["cmd"]
    _hx_methods = ["getSrcCompilationOptions", "getIncludePathOption", "getIncludeOption", "getBinaryCompilationOptions", "getDefineOption", "getOutputOptions", "getLibPathIncludeOption", "getLibOption"]


class hxmake_compilers_CL(hxmake_compilers_CompilerBase):
    _hx_class_name = "hxmake.compilers.CL"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["getSrcCompilationOptions", "getIncludePathOption", "getIncludeOption", "getBinaryCompilationOptions", "getDefineOption", "getOutputOptions", "getLibPathIncludeOption", "getLibOption"]
    _hx_statics = []
    _hx_interfaces = [hxmake_compilers_Compiler]
    _hx_super = hxmake_compilers_CompilerBase


    def __init__(self,h):
        super().__init__(h)
        self.cmd = "cl"

    def getSrcCompilationOptions(self):
        return ["/nologo", "/c", self.get_srcPath().toString()]

    def getIncludePathOption(self,includePath):
        return [("/I" + Std.string(includePath))]

    def getIncludeOption(self,include):
        return [("/FI" + Std.string(include))]

    def getBinaryCompilationOptions(self):
        return ["/LD", haxe_io_Path.join([self.get_outputPath().dir, haxe_io_Path.withExtension(self.get_outputPath().file,"obj")])]

    def getDefineOption(self,define):
        return [("/D" + ("null" if define is None else define))]

    def getOutputOptions(self):
        return ["/link", ("/OUT:" + Std.string(self.get_outputPath()))]

    def getLibPathIncludeOption(self,libPath):
        return [("/LIBPATH:" + Std.string(libPath))]

    def getLibOption(self,lib):
        return [haxe_io_Path.join([lib.dir, haxe_io_Path.withExtension(lib.file,"lib")])]



class hxmake_compilers_GCC(hxmake_compilers_CompilerBase):
    _hx_class_name = "hxmake.compilers.GCC"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["getSrcCompilationOptions", "getIncludePathOption", "getIncludeOption", "getBinaryCompilationOptions", "getDefineOption", "getOutputOptions", "getLibPathIncludeOption", "getLibOption"]
    _hx_statics = []
    _hx_interfaces = [hxmake_compilers_Compiler]
    _hx_super = hxmake_compilers_CompilerBase


    def __init__(self,h):
        super().__init__(h)
        self.cmd = "gcc"

    def getSrcCompilationOptions(self):
        return ["-c", self.get_srcPath().toString(), "-o", haxe_io_Path.join([self.get_outputPath().dir, haxe_io_Path.withExtension(self.get_outputPath().file,"obj")])]

    def getIncludePathOption(self,includePath):
        return ["-I", ("" + Std.string(includePath))]

    def getIncludeOption(self,include):
        return ["-include", ("" + Std.string(include))]

    def getBinaryCompilationOptions(self):
        ret = []
        if self.hxMake.winApi:
            ret.append("-mwindows")
        return (ret + ["-shared", "-o", ("" + Std.string(self.get_outputPath())), haxe_io_Path.join([self.get_outputPath().dir, haxe_io_Path.withExtension(self.get_outputPath().file,"obj")])])

    def getDefineOption(self,define):
        return ["-D", ("" + ("null" if define is None else define))]

    def getOutputOptions(self):
        return ["-o", ("" + Std.string(self.get_outputPath()))]

    def getLibPathIncludeOption(self,libPath):
        return [("-L" + Std.string(libPath))]

    def getLibOption(self,lib):
        return [("-l" + HxOverrides.stringOrNull(haxe_io_Path.join([lib.dir, lib.file])))]



class hxmake_compilers_CLang(hxmake_compilers_GCC):
    _hx_class_name = "hxmake.compilers.CLang"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = hxmake_compilers_GCC


    def __init__(self,h):
        super().__init__(h)
        self.cmd = "clang"


class hxmake_compilers_CompilerTools:
    _hx_class_name = "hxmake.compilers.CompilerTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["run"]

    @staticmethod
    def run(cmd,args,verbose = None):
        def _hx_local_0(c,a):
            return sys_io_Process(c,a).exitCode(True)
        newProcess = _hx_local_0
        ((Sys.command if verbose else newProcess))(cmd,args)


class python_Boot:
    _hx_class_name = "python.Boot"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["keywords", "toString1", "fields", "simpleField", "hasField", "field", "getInstanceFields", "getSuperClass", "getClassFields", "prefixLength", "unhandleKeywords"]

    @staticmethod
    def toString1(o,s):
        if (o is None):
            return "null"
        if isinstance(o,str):
            return o
        if (s is None):
            s = ""
        if (len(s) >= 5):
            return "<...>"
        if isinstance(o,bool):
            if o:
                return "true"
            else:
                return "false"
        if (isinstance(o,int) and (not isinstance(o,bool))):
            return str(o)
        if isinstance(o,float):
            try:
                if (o == int(o)):
                    return str(Math.floor((o + 0.5)))
                else:
                    return str(o)
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                e = _hx_e1
                return str(o)
        if isinstance(o,list):
            o1 = o
            l = len(o1)
            st = "["
            s = (("null" if s is None else s) + "\t")
            _g = 0
            _g1 = l
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                prefix = ""
                if (i > 0):
                    prefix = ","
                st = (("null" if st is None else st) + HxOverrides.stringOrNull(((("null" if prefix is None else prefix) + HxOverrides.stringOrNull(python_Boot.toString1((o1[i] if i >= 0 and i < len(o1) else None),s))))))
            st = (("null" if st is None else st) + "]")
            return st
        try:
            if hasattr(o,"toString"):
                return o.toString()
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        if hasattr(o,"__class__"):
            if isinstance(o,_hx_AnonObject):
                toStr = None
                try:
                    fields = python_Boot.fields(o)
                    _g2 = []
                    _g11 = 0
                    while (_g11 < len(fields)):
                        f = (fields[_g11] if _g11 >= 0 and _g11 < len(fields) else None)
                        _g11 = (_g11 + 1)
                        x = ((("" + ("null" if f is None else f)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f),(("null" if s is None else s) + "\t"))))
                        _g2.append(x)
                    fieldsStr = _g2
                    toStr = (("{ " + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr]))) + " }")
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e2 = _hx_e1
                    return "{ ... }"
                if (toStr is None):
                    return "{ ... }"
                else:
                    return toStr
            if isinstance(o,Enum):
                o2 = o
                l1 = len(o2.params)
                hasParams = (l1 > 0)
                if hasParams:
                    paramsStr = ""
                    _g3 = 0
                    _g12 = l1
                    while (_g3 < _g12):
                        i1 = _g3
                        _g3 = (_g3 + 1)
                        prefix1 = ""
                        if (i1 > 0):
                            prefix1 = ","
                        paramsStr = (("null" if paramsStr is None else paramsStr) + HxOverrides.stringOrNull(((("null" if prefix1 is None else prefix1) + HxOverrides.stringOrNull(python_Boot.toString1(o2.params[i1],s))))))
                    return (((HxOverrides.stringOrNull(o2.tag) + "(") + ("null" if paramsStr is None else paramsStr)) + ")")
                else:
                    return o2.tag
            if hasattr(o,"_hx_class_name"):
                if (o.__class__.__name__ != "type"):
                    fields1 = python_Boot.getInstanceFields(o)
                    _g4 = []
                    _g13 = 0
                    while (_g13 < len(fields1)):
                        f1 = (fields1[_g13] if _g13 >= 0 and _g13 < len(fields1) else None)
                        _g13 = (_g13 + 1)
                        x1 = ((("" + ("null" if f1 is None else f1)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f1),(("null" if s is None else s) + "\t"))))
                        _g4.append(x1)
                    fieldsStr1 = _g4
                    toStr1 = (((HxOverrides.stringOrNull(o._hx_class_name) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr1]))) + " )")
                    return toStr1
                else:
                    fields2 = python_Boot.getClassFields(o)
                    _g5 = []
                    _g14 = 0
                    while (_g14 < len(fields2)):
                        f2 = (fields2[_g14] if _g14 >= 0 and _g14 < len(fields2) else None)
                        _g14 = (_g14 + 1)
                        x2 = ((("" + ("null" if f2 is None else f2)) + " : ") + HxOverrides.stringOrNull(python_Boot.toString1(python_Boot.simpleField(o,f2),(("null" if s is None else s) + "\t"))))
                        _g5.append(x2)
                    fieldsStr2 = _g5
                    toStr2 = (((("#" + HxOverrides.stringOrNull(o._hx_class_name)) + "( ") + HxOverrides.stringOrNull(", ".join([x1 for x1 in fieldsStr2]))) + " )")
                    return toStr2
            if (o == str):
                return "#String"
            if (o == list):
                return "#Array"
            if callable(o):
                return "function"
            try:
                if hasattr(o,"__repr__"):
                    return o.__repr__()
            except Exception as _hx_e:
                _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                pass
            if hasattr(o,"__str__"):
                return o.__str__([])
            if hasattr(o,"__name__"):
                return o.__name__
            return "???"
        else:
            return str(o)

    @staticmethod
    def fields(o):
        a = []
        if (o is not None):
            if hasattr(o,"_hx_fields"):
                fields = o._hx_fields
                if (fields is not None):
                    return list(fields)
            if isinstance(o,_hx_AnonObject):
                d = o.__dict__
                keys = d.keys()
                handler = python_Boot.unhandleKeywords
                for k in keys:
                    if (k != '_hx_disable_getattr'):
                        a.append(handler(k))
            elif hasattr(o,"__dict__"):
                d1 = o.__dict__
                keys1 = d1.keys()
                for k in keys1:
                    a.append(k)
        return a

    @staticmethod
    def simpleField(o,field):
        if (field is None):
            return None
        field1 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
        if hasattr(o,field1):
            return getattr(o,field1)
        else:
            return None

    @staticmethod
    def hasField(o,field):
        if isinstance(o,_hx_AnonObject):
            return o._hx_hasattr(field)
        return hasattr(o,(("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field)))

    @staticmethod
    def field(o,field):
        if (field is None):
            return None
        if isinstance(o,str):
            field1 = field
            _hx_local_0 = len(field1)
            if (_hx_local_0 == 10):
                if (field1 == "charCodeAt"):
                    return python_internal_MethodClosure(o,HxString.charCodeAt)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 11):
                if (field1 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,HxString.lastIndexOf)
                elif (field1 == "toLowerCase"):
                    return python_internal_MethodClosure(o,HxString.toLowerCase)
                elif (field1 == "toUpperCase"):
                    return python_internal_MethodClosure(o,HxString.toUpperCase)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 9):
                if (field1 == "substring"):
                    return python_internal_MethodClosure(o,HxString.substring)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 5):
                if (field1 == "split"):
                    return python_internal_MethodClosure(o,HxString.split)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 7):
                if (field1 == "indexOf"):
                    return python_internal_MethodClosure(o,HxString.indexOf)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 8):
                if (field1 == "toString"):
                    return python_internal_MethodClosure(o,HxString.toString)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            elif (_hx_local_0 == 6):
                if (field1 == "charAt"):
                    return python_internal_MethodClosure(o,HxString.charAt)
                elif (field1 == "length"):
                    return len(o)
                elif (field1 == "substr"):
                    return python_internal_MethodClosure(o,HxString.substr)
                else:
                    field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field2) if (hasattr(o,field2)) else None)
            else:
                field2 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field2) if (hasattr(o,field2)) else None)
        elif isinstance(o,list):
            field3 = field
            _hx_local_1 = len(field3)
            if (_hx_local_1 == 11):
                if (field3 == "lastIndexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.lastIndexOf)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 4):
                if (field3 == "copy"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.copy)
                elif (field3 == "join"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.join)
                elif (field3 == "push"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.push)
                elif (field3 == "sort"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.sort)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 5):
                if (field3 == "shift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.shift)
                elif (field3 == "slice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.slice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 7):
                if (field3 == "indexOf"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.indexOf)
                elif (field3 == "reverse"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.reverse)
                elif (field3 == "unshift"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.unshift)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 3):
                if (field3 == "map"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.map)
                elif (field3 == "pop"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.pop)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 8):
                if (field3 == "iterator"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.iterator)
                elif (field3 == "toString"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.toString)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            elif (_hx_local_1 == 6):
                if (field3 == "concat"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.concat)
                elif (field3 == "filter"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.filter)
                elif (field3 == "insert"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.insert)
                elif (field3 == "length"):
                    return len(o)
                elif (field3 == "remove"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.remove)
                elif (field3 == "splice"):
                    return python_internal_MethodClosure(o,python_internal_ArrayImpl.splice)
                else:
                    field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                    return (getattr(o,field4) if (hasattr(o,field4)) else None)
            else:
                field4 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
                return (getattr(o,field4) if (hasattr(o,field4)) else None)
        else:
            field5 = (("_hx_" + field) if ((field in python_Boot.keywords)) else (("_hx_" + field) if (((((len(field) > 2) and ((ord(field[0]) == 95))) and ((ord(field[1]) == 95))) and ((ord(field[(len(field) - 1)]) != 95)))) else field))
            return (getattr(o,field5) if (hasattr(o,field5)) else None)

    @staticmethod
    def getInstanceFields(c):
        f = (list(c._hx_fields) if (hasattr(c,"_hx_fields")) else [])
        if hasattr(c,"_hx_methods"):
            f = (f + c._hx_methods)
        sc = python_Boot.getSuperClass(c)
        if (sc is None):
            return f
        else:
            scArr = python_Boot.getInstanceFields(sc)
            scMap = set(scArr)
            _g = 0
            while (_g < len(f)):
                f1 = (f[_g] if _g >= 0 and _g < len(f) else None)
                _g = (_g + 1)
                if (not (f1 in scMap)):
                    scArr.append(f1)
            return scArr

    @staticmethod
    def getSuperClass(c):
        if (c is None):
            return None
        try:
            if hasattr(c,"_hx_super"):
                return c._hx_super
            return None
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            pass
        return None

    @staticmethod
    def getClassFields(c):
        if hasattr(c,"_hx_statics"):
            x = c._hx_statics
            return list(x)
        else:
            return []

    @staticmethod
    def unhandleKeywords(name):
        if (HxString.substr(name,0,python_Boot.prefixLength) == "_hx_"):
            real = HxString.substr(name,python_Boot.prefixLength,None)
            if (real in python_Boot.keywords):
                return real
        return name


class python__KwArgs_KwArgs_Impl_:
    _hx_class_name = "python._KwArgs.KwArgs_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["fromT"]

    @staticmethod
    def fromT(d):
        this1 = python_Lib.anonAsDict(d)
        return this1


class python_Lib:
    _hx_class_name = "python.Lib"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["lineEnd", "printString", "anonToDict", "anonAsDict"]
    __name__ = None

    @staticmethod
    def printString(_hx_str):
        encoding = "utf-8"
        if (encoding is None):
            encoding = "utf-8"
        python_lib_Sys.stdout.buffer.write(_hx_str.encode(encoding, "strict"))
        python_lib_Sys.stdout.flush()

    @staticmethod
    def anonToDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__.copy()
        else:
            return None

    @staticmethod
    def anonAsDict(o):
        if isinstance(o,_hx_AnonObject):
            return o.__dict__
        else:
            return None


class python_internal_ArrayImpl:
    _hx_class_name = "python.internal.ArrayImpl"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["concat", "copy", "iterator", "indexOf", "lastIndexOf", "join", "toString", "pop", "push", "unshift", "remove", "shift", "slice", "sort", "splice", "map", "filter", "insert", "reverse", "_get", "_set"]

    @staticmethod
    def concat(a1,a2):
        return (a1 + a2)

    @staticmethod
    def copy(x):
        return list(x)

    @staticmethod
    def iterator(x):
        return python_HaxeIterator(x.__iter__())

    @staticmethod
    def indexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (0 if ((fromIndex is None)) else ((_hx_len + fromIndex) if ((fromIndex < 0)) else fromIndex))
        if (l < 0):
            l = 0
        _g = l
        _g1 = _hx_len
        while (_g < _g1):
            i = _g
            _g = (_g + 1)
            if HxOverrides.eq(a[i],x):
                return i
        return -1

    @staticmethod
    def lastIndexOf(a,x,fromIndex = None):
        _hx_len = len(a)
        l = (_hx_len if ((fromIndex is None)) else (((_hx_len + fromIndex) + 1) if ((fromIndex < 0)) else (fromIndex + 1)))
        if (l > _hx_len):
            l = _hx_len
        while True:
            l = (l - 1)
            tmp = l
            if (not ((tmp > -1))):
                break
            if HxOverrides.eq(a[l],x):
                return l
        return -1

    @staticmethod
    def join(x,sep):
        return sep.join([python_Boot.toString1(x1,'') for x1 in x])

    @staticmethod
    def toString(x):
        return (("[" + HxOverrides.stringOrNull(",".join([python_Boot.toString1(x1,'') for x1 in x]))) + "]")

    @staticmethod
    def pop(x):
        if (len(x) == 0):
            return None
        else:
            return x.pop()

    @staticmethod
    def push(x,e):
        x.append(e)
        return len(x)

    @staticmethod
    def unshift(x,e):
        x.insert(0, e)

    @staticmethod
    def remove(x,e):
        try:
            x.remove(e)
            return True
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e1 = _hx_e1
            return False

    @staticmethod
    def shift(x):
        if (len(x) == 0):
            return None
        return x.pop(0)

    @staticmethod
    def slice(x,pos,end = None):
        return x[pos:end]

    @staticmethod
    def sort(x,f):
        x.sort(key= python_lib_Functools.cmp_to_key(f))

    @staticmethod
    def splice(x,pos,_hx_len):
        if (pos < 0):
            pos = (len(x) + pos)
        if (pos < 0):
            pos = 0
        res = x[pos:(pos + _hx_len)]
        del x[pos:(pos + _hx_len)]
        return res

    @staticmethod
    def map(x,f):
        return list(map(f,x))

    @staticmethod
    def filter(x,f):
        return list(filter(f,x))

    @staticmethod
    def insert(a,pos,x):
        a.insert(pos, x)

    @staticmethod
    def reverse(a):
        a.reverse()

    @staticmethod
    def _get(x,idx):
        if ((idx > -1) and ((idx < len(x)))):
            return x[idx]
        else:
            return None

    @staticmethod
    def _set(x,idx,v):
        l = len(x)
        while (l < idx):
            x.append(None)
            l = (l + 1)
        if (l == idx):
            x.append(v)
        else:
            x[idx] = v
        return v


class _HxException(Exception):
    _hx_class_name = "_HxException"
    _hx_is_interface = "False"
    __slots__ = ("val",)
    _hx_fields = ["val"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = Exception


    def __init__(self,val):
        self.val = None
        message = str(val)
        super().__init__(message)
        self.val = val



class HxOverrides:
    _hx_class_name = "HxOverrides"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["iterator", "eq", "stringOrNull", "modf", "mod", "mapKwArgs"]

    @staticmethod
    def iterator(x):
        if isinstance(x,list):
            return python_HaxeIterator(x.__iter__())
        return x.iterator()

    @staticmethod
    def eq(a,b):
        if (isinstance(a,list) or isinstance(b,list)):
            return a is b
        return (a == b)

    @staticmethod
    def stringOrNull(s):
        if (s is None):
            return "null"
        else:
            return s

    @staticmethod
    def modf(a,b):
        if (b == 0.0):
            return float('nan')
        elif (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mod(a,b):
        if (a < 0):
            if (b < 0):
                return -(-a % (-b))
            else:
                return -(-a % b)
        elif (b < 0):
            return a % (-b)
        else:
            return a % b

    @staticmethod
    def mapKwArgs(a,v):
        a1 = _hx_AnonObject(python_Lib.anonToDict(a))
        k = python_HaxeIterator(iter(v.keys()))
        while k.hasNext():
            k1 = k.next()
            val = v.get(k1)
            if a1._hx_hasattr(k1):
                x = getattr(a1,k1)
                setattr(a1,val,x)
                delattr(a1,k1)
        return a1


class python_internal_MethodClosure:
    _hx_class_name = "python.internal.MethodClosure"
    _hx_is_interface = "False"
    __slots__ = ("obj", "func")
    _hx_fields = ["obj", "func"]
    _hx_methods = ["__call__"]

    def __init__(self,obj,func):
        self.obj = obj
        self.func = func

    def __call__(self,*args):
        return self.func(self.obj,*args)



class HxString:
    _hx_class_name = "HxString"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["split", "charCodeAt", "charAt", "lastIndexOf", "toUpperCase", "toLowerCase", "indexOf", "toString", "substring", "substr"]

    @staticmethod
    def split(s,d):
        if (d == ""):
            return list(s)
        else:
            return s.split(d)

    @staticmethod
    def charCodeAt(s,index):
        if ((((s is None) or ((len(s) == 0))) or ((index < 0))) or ((index >= len(s)))):
            return None
        else:
            return ord(s[index])

    @staticmethod
    def charAt(s,index):
        if ((index < 0) or ((index >= len(s)))):
            return ""
        else:
            return s[index]

    @staticmethod
    def lastIndexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.rfind(_hx_str, 0, len(s))
        else:
            i = s.rfind(_hx_str, 0, (startIndex + 1))
            startLeft = (max(0,((startIndex + 1) - len(_hx_str))) if ((i == -1)) else (i + 1))
            check = s.find(_hx_str, startLeft, len(s))
            if ((check > i) and ((check <= startIndex))):
                return check
            else:
                return i

    @staticmethod
    def toUpperCase(s):
        return s.upper()

    @staticmethod
    def toLowerCase(s):
        return s.lower()

    @staticmethod
    def indexOf(s,_hx_str,startIndex = None):
        if (startIndex is None):
            return s.find(_hx_str)
        else:
            return s.find(_hx_str, startIndex)

    @staticmethod
    def toString(s):
        return s

    @staticmethod
    def substring(s,startIndex,endIndex = None):
        if (startIndex < 0):
            startIndex = 0
        if (endIndex is None):
            return s[startIndex:]
        else:
            if (endIndex < 0):
                endIndex = 0
            if (endIndex < startIndex):
                return s[endIndex:startIndex]
            else:
                return s[startIndex:endIndex]

    @staticmethod
    def substr(s,startIndex,_hx_len = None):
        if (_hx_len is None):
            return s[startIndex:]
        else:
            if (_hx_len == 0):
                return ""
            if (startIndex < 0):
                startIndex = (len(s) + startIndex)
                if (startIndex < 0):
                    startIndex = 0
            return s[startIndex:(startIndex + _hx_len)]


class python_io_NativeInput(haxe_io_Input):
    _hx_class_name = "python.io.NativeInput"
    _hx_is_interface = "False"
    __slots__ = ("stream", "wasEof")
    _hx_fields = ["stream", "wasEof"]
    _hx_methods = ["throwEof"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,s):
        self.wasEof = None
        self.stream = s
        self.set_bigEndian(False)
        self.wasEof = False
        if (not self.stream.readable()):
            raise _HxException("Write-only stream")

    def throwEof(self):
        self.wasEof = True
        raise _HxException(haxe_io_Eof())



class python_io_IInput:
    _hx_class_name = "python.io.IInput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian", "readByte", "readLine"]


class python_io_IFileInput:
    _hx_class_name = "python.io.IFileInput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [python_io_IInput]


class python_io_NativeOutput(haxe_io_Output):
    _hx_class_name = "python.io.NativeOutput"
    _hx_is_interface = "False"
    __slots__ = ("stream",)
    _hx_fields = ["stream"]
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,stream):
        self.stream = None
        self.set_bigEndian(False)
        self.stream = stream
        if (not stream.writable()):
            raise _HxException("Read only stream")



class python_io_IOutput:
    _hx_class_name = "python.io.IOutput"
    _hx_is_interface = "True"
    __slots__ = ("bigEndian",)
    _hx_fields = ["bigEndian"]
    _hx_methods = ["set_bigEndian"]


class python_io_IFileOutput:
    _hx_class_name = "python.io.IFileOutput"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_interfaces = [python_io_IOutput]


class python_io_NativeTextInput(python_io_NativeInput):
    _hx_class_name = "python.io.NativeTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["readByte"]
    _hx_statics = []
    _hx_interfaces = [python_io_IInput]
    _hx_super = python_io_NativeInput


    def __init__(self,stream):
        super().__init__(stream)

    def readByte(self):
        ret = self.stream.buffer.read(1)
        if (len(ret) == 0):
            self.throwEof()
        return ret[0]



class python_io_FileTextInput(python_io_NativeTextInput):
    _hx_class_name = "python.io.FileTextInput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileInput]
    _hx_super = python_io_NativeTextInput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_NativeTextOutput(python_io_NativeOutput):
    _hx_class_name = "python.io.NativeTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = python_io_NativeOutput


    def __init__(self,stream):
        super().__init__(stream)
        if (not stream.writable()):
            raise _HxException("Read only stream")


class python_io_FileTextOutput(python_io_NativeTextOutput):
    _hx_class_name = "python.io.FileTextOutput"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = []
    _hx_statics = []
    _hx_interfaces = [python_io_IFileOutput]
    _hx_super = python_io_NativeTextOutput


    def __init__(self,stream):
        super().__init__(stream)


class python_io_IoTools:
    _hx_class_name = "python.io.IoTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["createFileInputFromText", "createFileOutputFromText"]

    @staticmethod
    def createFileInputFromText(t):
        return sys_io_FileInput(python_io_FileTextInput(t))

    @staticmethod
    def createFileOutputFromText(t):
        return sys_io_FileOutput(python_io_FileTextOutput(t))


class sys_io_File:
    _hx_class_name = "sys.io.File"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["getContent"]

    @staticmethod
    def getContent(path):
        f = python_lib_Builtins.open(path,"r",-1,"utf-8",None,"")
        content = f.read(-1)
        f.close()
        return content


class sys_io_FileInput(haxe_io_Input):
    _hx_class_name = "sys.io.FileInput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian", "readByte", "readLine"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Input


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)

    def readByte(self):
        return self.impl.readByte()

    def readLine(self):
        return self.impl.readLine()



class sys_io_FileOutput(haxe_io_Output):
    _hx_class_name = "sys.io.FileOutput"
    _hx_is_interface = "False"
    __slots__ = ("impl",)
    _hx_fields = ["impl"]
    _hx_methods = ["set_bigEndian"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = haxe_io_Output


    def __init__(self,impl):
        self.impl = impl

    def set_bigEndian(self,b):
        return self.impl.set_bigEndian(b)



class sys_io_Process:
    _hx_class_name = "sys.io.Process"
    _hx_is_interface = "False"
    __slots__ = ("stdout", "stderr", "stdin", "p")
    _hx_fields = ["stdout", "stderr", "stdin", "p"]
    _hx_methods = ["exitCode"]

    def __init__(self,cmd,args = None,detached = None):
        self.stdin = None
        self.stderr = None
        self.stdout = None
        if detached:
            raise _HxException("Detached process is not supported on this platform")
        args1 = (cmd if ((args is None)) else ([cmd] + args))
        o = _hx_AnonObject({'shell': (args is None), 'stdin': python_lib_Subprocess.PIPE, 'stdout': python_lib_Subprocess.PIPE, 'stderr': python_lib_Subprocess.PIPE})
        Reflect.setField(o,"bufsize",(Reflect.field(o,"bufsize") if (python_Boot.hasField(o,"bufsize")) else 0))
        Reflect.setField(o,"executable",(Reflect.field(o,"executable") if (python_Boot.hasField(o,"executable")) else None))
        Reflect.setField(o,"stdin",(Reflect.field(o,"stdin") if (python_Boot.hasField(o,"stdin")) else None))
        Reflect.setField(o,"stdout",(Reflect.field(o,"stdout") if (python_Boot.hasField(o,"stdout")) else None))
        Reflect.setField(o,"stderr",(Reflect.field(o,"stderr") if (python_Boot.hasField(o,"stderr")) else None))
        Reflect.setField(o,"preexec_fn",(Reflect.field(o,"preexec_fn") if (python_Boot.hasField(o,"preexec_fn")) else None))
        Reflect.setField(o,"close_fds",(Reflect.field(o,"close_fds") if (python_Boot.hasField(o,"close_fds")) else None))
        Reflect.setField(o,"shell",(Reflect.field(o,"shell") if (python_Boot.hasField(o,"shell")) else None))
        Reflect.setField(o,"cwd",(Reflect.field(o,"cwd") if (python_Boot.hasField(o,"cwd")) else None))
        Reflect.setField(o,"env",(Reflect.field(o,"env") if (python_Boot.hasField(o,"env")) else None))
        Reflect.setField(o,"universal_newlines",(Reflect.field(o,"universal_newlines") if (python_Boot.hasField(o,"universal_newlines")) else None))
        Reflect.setField(o,"startupinfo",(Reflect.field(o,"startupinfo") if (python_Boot.hasField(o,"startupinfo")) else None))
        Reflect.setField(o,"creationflags",(Reflect.field(o,"creationflags") if (python_Boot.hasField(o,"creationflags")) else 0))
        self.p = (python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo"),Reflect.field(o,"creationflags")) if ((Sys.systemName() == "Windows")) else python_lib_subprocess_Popen(args1,Reflect.field(o,"bufsize"),Reflect.field(o,"executable"),Reflect.field(o,"stdin"),Reflect.field(o,"stdout"),Reflect.field(o,"stderr"),Reflect.field(o,"preexec_fn"),Reflect.field(o,"close_fds"),Reflect.field(o,"shell"),Reflect.field(o,"cwd"),Reflect.field(o,"env"),Reflect.field(o,"universal_newlines"),Reflect.field(o,"startupinfo")))
        self.stdout = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stdout)))
        self.stderr = python_io_IoTools.createFileInputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedReader(self.p.stderr)))
        self.stdin = python_io_IoTools.createFileOutputFromText(python_lib_io_TextIOWrapper(python_lib_io_BufferedWriter(self.p.stdin)))

    def exitCode(self,block = None):
        if (block is None):
            block = True
        if (block == False):
            return self.p.poll()
        return self.p.wait()



class tink_Cli:
    _hx_class_name = "tink.Cli"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["exit"]

    @staticmethod
    def exit(result):
        tmp = result.index
        if (tmp == 0):
            _g = result.params[0]
            Sys.exit(0)
        elif (tmp == 1):
            e = result.params[0]
            message = e.message
            if (e.data is not None):
                message = (("null" if message is None else message) + ((", " + Std.string(e.data))))
            _hx_str = Std.string(message)
            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
            Sys.exit(e.code)
        else:
            pass


class tink__Stringly_Stringly_Impl_:
    _hx_class_name = "tink._Stringly.Stringly_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["isNumber", "toBool", "isFloat", "parseFloat", "toFloat", "isInt", "parseInt", "toInt", "SUPPORTED_DATE_REGEX", "parseDate", "toDate", "parse", "ofBool", "ofInt", "ofFloat", "ofDate"]

    @staticmethod
    def isNumber(s,allowFloat):
        if (len(s) == 0):
            return False
        pos = 0
        _hx_max = len(s)
        if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 45))):
            pos = (pos + 1)
        if (not allowFloat):
            tmp = None
            if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 48))):
                tmp1 = pos
                pos = (pos + 1)
                tmp = (tmp1 > -1)
            else:
                tmp = False
            if tmp:
                if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 120))):
                    pos = (pos + 1)
        while ((pos < _hx_max) and ((((((-1 if ((pos >= len(s))) else ord(s[pos]))) ^ 48)) < 10))):
            pos = (pos + 1)
        if (allowFloat and ((pos < _hx_max))):
            tmp2 = None
            if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 46))):
                tmp3 = pos
                pos = (pos + 1)
                tmp2 = (tmp3 > -1)
            else:
                tmp2 = False
            if tmp2:
                while ((pos < _hx_max) and ((((((-1 if ((pos >= len(s))) else ord(s[pos]))) ^ 48)) < 10))):
                    pos = (pos + 1)
            tmp4 = None
            tmp5 = None
            if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 101))):
                tmp6 = pos
                pos = (pos + 1)
                tmp5 = (tmp6 > -1)
            else:
                tmp5 = False
            if (not tmp5):
                if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 69))):
                    tmp7 = pos
                    pos = (pos + 1)
                    tmp4 = (tmp7 > -1)
                else:
                    tmp4 = False
            else:
                tmp4 = True
            if tmp4:
                tmp8 = None
                if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 43))):
                    tmp9 = pos
                    pos = (pos + 1)
                    tmp8 = (tmp9 > -1)
                else:
                    tmp8 = False
                if (not tmp8):
                    if ((pos < _hx_max) and ((((-1 if ((pos >= len(s))) else ord(s[pos]))) == 45))):
                        pos = (pos + 1)
                while ((pos < _hx_max) and ((((((-1 if ((pos >= len(s))) else ord(s[pos]))) ^ 48)) < 10))):
                    pos = (pos + 1)
        return (pos == _hx_max)

    @staticmethod
    def toBool(this1):
        if (this1 is not None):
            _g = StringTools.trim(this1).lower()
            _hx_local_0 = len(_g)
            if (_hx_local_0 == 1):
                if (_g == "0"):
                    return False
                else:
                    return True
            elif (_hx_local_0 == 5):
                if (_g == "false"):
                    return False
                else:
                    return True
            elif (_hx_local_0 == 2):
                if (_g == "no"):
                    return False
                else:
                    return True
            else:
                return True
        else:
            return False

    @staticmethod
    def isFloat(this1):
        return tink__Stringly_Stringly_Impl_.isNumber(StringTools.trim(this1),True)

    @staticmethod
    def parseFloat(this1):
        _g = StringTools.trim(this1)
        v = _g
        if tink__Stringly_Stringly_Impl_.isNumber(v,True):
            return tink_core_Outcome.Success(Std.parseFloat(v))
        else:
            v1 = _g
            return tink_core_Outcome.Failure(tink_core_TypedError(422,(((("" + ("null" if v1 is None else v1)) + " (encoded as ") + ("null" if this1 is None else this1)) + ") is not a valid float"),_hx_AnonObject({'fileName': "tink/Stringly.hx", 'lineNumber': 64, 'className': "tink._Stringly.Stringly_Impl_", 'methodName': "parseFloat"})))

    @staticmethod
    def toFloat(this1):
        return tink_core_OutcomeTools.sure(tink__Stringly_Stringly_Impl_.parseFloat(this1))

    @staticmethod
    def isInt(this1):
        return tink__Stringly_Stringly_Impl_.isNumber(StringTools.trim(this1),False)

    @staticmethod
    def parseInt(this1):
        _g = StringTools.trim(this1)
        v = _g
        if tink__Stringly_Stringly_Impl_.isNumber(v,False):
            return tink_core_Outcome.Success(Std.parseInt(v))
        else:
            v1 = _g
            return tink_core_Outcome.Failure(tink_core_TypedError(422,(((("" + ("null" if v1 is None else v1)) + " (encoded as ") + ("null" if this1 is None else this1)) + ") is not a valid integer"),_hx_AnonObject({'fileName': "tink/Stringly.hx", 'lineNumber': 79, 'className': "tink._Stringly.Stringly_Impl_", 'methodName': "parseInt"})))

    @staticmethod
    def toInt(this1):
        return tink_core_OutcomeTools.sure(tink__Stringly_Stringly_Impl_.parseInt(this1))

    @staticmethod
    def parseDate(this1):
        _g = tink__Stringly_Stringly_Impl_.parseFloat(this1)
        tmp = _g.index
        if (tmp == 0):
            f = _g.params[0]
            return tink_core_Outcome.Success(Date.fromTime(f))
        elif (tmp == 1):
            _g2 = _g.params[0]
            _this = tink__Stringly_Stringly_Impl_.SUPPORTED_DATE_REGEX
            _this.matchObj = python_lib_Re.search(_this.pattern,this1)
            if (_this.matchObj is None):
                return tink_core_Outcome.Failure(tink_core_TypedError(422,(("" + HxOverrides.stringOrNull(this1)) + " is not a valid date"),_hx_AnonObject({'fileName': "tink/Stringly.hx", 'lineNumber': 100, 'className': "tink._Stringly.Stringly_Impl_", 'methodName': "parseDate"})))
            _this1 = tink__Stringly_Stringly_Impl_.SUPPORTED_DATE_REGEX.matchObj.group(1)
            s = _this1.split("T")
            _this2 = (s[0] if 0 < len(s) else None)
            d = _this2.split("-")
            _this3 = (s[1] if 1 < len(s) else None)
            t = _this3.split(":")
            y = (Std.parseInt((d[0] if 0 < len(d) else None)) - 1970)
            m = Std.parseInt((d[1] if 1 < len(d) else None))
            d1 = Std.parseInt((d[2] if 2 < len(d) else None))
            hh = Std.parseInt((t[0] if 0 < len(t) else None))
            mm = Std.parseInt((t[1] if 1 < len(t) else None))
            ss = Std.parseInt((t[2] if 2 < len(t) else None))
            days = (((y * 365) + d1) - 1)
            days1 = None
            if (y < 2):
                days1 = 0
            else:
                days2 = None
                try:
                    days2 = int((((y - 2)) / 4))
                except Exception as _hx_e:
                    _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
                    e = _hx_e1
                    days2 = None
                days1 = days2
            days = (days + days1)
            daysOfMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
            _g1 = 0
            _g11 = (m - 1)
            while (_g1 < _g11):
                m1 = _g1
                _g1 = (_g1 + 1)
                days = (days + (daysOfMonth[m1] if m1 >= 0 and m1 < len(daysOfMonth) else None))
            if (y >= 2):
                if ((HxOverrides.mod(((y - 2)), 4) != 0) or ((m >= 3))):
                    days = (days + 1)
            stamp = ((((days * 86400) + ((hh * 3600))) + ((mm * 60))) + ss)
            _g21 = tink__Stringly_Stringly_Impl_.SUPPORTED_DATE_REGEX.matchObj.group(2)
            stamp1 = None
            if (_g21 is None):
                stamp1 = 0.0
            else:
                v = _g21
                stamp1 = (Std.parseInt(HxString.substr(v,1,None)) / 1000)
            stamp2 = (stamp + stamp1)
            _g3 = tink__Stringly_Stringly_Impl_.SUPPORTED_DATE_REGEX.matchObj.group(3)
            stamp3 = None
            if (_g3 == "Z"):
                stamp3 = 0.0
            else:
                v1 = _g3
                positive = (HxString.charCodeAt(v1,0) == 43)
                _this4 = HxString.substr(v1,1,None)
                s1 = _this4.split(":")
                stamp3 = ((((Std.parseInt((s1[0] if 0 < len(s1) else None)) * 3600) + ((Std.parseInt((s1[1] if 1 < len(s1) else None)) * 60)))) * ((-1 if positive else 1)))
            stamp4 = (stamp2 + stamp3)
            return tink_core_Outcome.Success(Date.fromTime((stamp4 * 1000)))
        else:
            pass

    @staticmethod
    def toDate(this1):
        return tink_core_OutcomeTools.sure(tink__Stringly_Stringly_Impl_.parseDate(this1))

    @staticmethod
    def parse(this1,f):
        f1 = f
        a1 = this1
        def _hx_local_1():
            def _hx_local_0():
                return f1(a1)
            return tink_core_TypedError.catchExceptions(_hx_local_0,None,_hx_AnonObject({'fileName': "tink/Stringly.hx", 'lineNumber': 163, 'className': "tink._Stringly.Stringly_Impl_", 'methodName': "parse"}))
        return _hx_local_1()

    @staticmethod
    def ofBool(b):
        if b:
            return "true"
        else:
            return "false"

    @staticmethod
    def ofInt(i):
        return Std.string(i)

    @staticmethod
    def ofFloat(f):
        return Std.string(f)

    @staticmethod
    def ofDate(d):
        return Std.string((d.date.timestamp() * 1000))


class tink_cli_DocFormatter:
    _hx_class_name = "tink.cli.DocFormatter"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["format"]


class tink_cli_Prompt:
    _hx_class_name = "tink.cli.Prompt"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["print", "println", "prompt"]


class tink_cli__Prompt_PromptType_Impl_:
    _hx_class_name = "tink.cli._Prompt.PromptType_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofString"]

    @staticmethod
    def ofString(v):
        return tink_cli_PromptTypeBase.Simple(v)

class tink_cli_PromptTypeBase(Enum):
    __slots__ = ()
    _hx_class_name = "tink.cli.PromptTypeBase"

    @staticmethod
    def Simple(prompt):
        return tink_cli_PromptTypeBase("Simple", 0, (prompt,))

    @staticmethod
    def MultipleChoices(prompt,choices):
        return tink_cli_PromptTypeBase("MultipleChoices", 1, (prompt,choices))

    @staticmethod
    def Secure(prompt):
        return tink_cli_PromptTypeBase("Secure", 2, (prompt,))


class tink_cli__Rest_Rest_Impl_:
    _hx_class_name = "tink.cli._Rest.Rest_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["asArray"]

    @staticmethod
    def asArray(this1):
        return this1


class tink_cli_Router:
    _hx_class_name = "tink.cli.Router"
    _hx_is_interface = "False"
    __slots__ = ("command", "prompt", "hasFlags")
    _hx_fields = ["command", "prompt", "hasFlags"]
    _hx_methods = ["process", "processArgs", "processFlag", "processAlias", "promptRequired"]
    _hx_statics = ["expandAssignments"]

    def __init__(self,command,prompt,hasFlags):
        self.command = command
        self.prompt = prompt
        self.hasFlags = hasFlags

    def process(self,args):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))

    def processArgs(self,args):
        _gthis = self
        if (not self.hasFlags):
            return tink_core_Outcome.Success(args)
        else:
            def _hx_local_5():
                def _hx_local_4():
                    args1 = tink_cli_Router.expandAssignments(args)
                    rest = []
                    i = 0
                    flagsEnded = False
                    while (i < len(args1)):
                        arg = (args1[i] if i >= 0 and i < len(args1) else None)
                        if (arg == "--"):
                            flagsEnded = True
                            i = (i + 1)
                        elif ((not flagsEnded) and ((HxString.charCodeAt(arg,0) == 45))):
                            _g = _gthis.processFlag(args1,i)
                            if (_g == -1):
                                if (HxString.charCodeAt(arg,1) != 45):
                                    _g1 = _gthis.processAlias(args1,i)
                                    if (_g1 == -1):
                                        raise _HxException((("Unrecognized alias \"" + ("null" if arg is None else arg)) + "\""))
                                    else:
                                        v = _g1
                                        i = (i + ((v + 1)))
                                else:
                                    raise _HxException((("Unrecognized flag \"" + ("null" if arg is None else arg)) + "\""))
                            else:
                                v1 = _g
                                i = (i + ((v1 + 1)))
                        else:
                            rest.append(arg)
                            i = (i + 1)
                    return rest
                return tink_core_TypedError.catchExceptions(_hx_local_4,None,_hx_AnonObject({'fileName': "tink/cli/Router.hx", 'lineNumber': 25, 'className': "tink.cli.Router", 'methodName': "processArgs"}))
            return _hx_local_5()

    def processFlag(self,args,index):
        return -1

    def processAlias(self,args,index):
        return -1

    def promptRequired(self):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))

    @staticmethod
    def expandAssignments(args):
        ret = []
        flags = True
        _g = 0
        while (_g < len(args)):
            arg = (args[_g] if _g >= 0 and _g < len(args) else None)
            _g = (_g + 1)
            if (arg == "--"):
                flags = False
            if (not flags):
                ret.append(arg)
            else:
                startIndex = None
                _g1 = (arg.find("=") if ((startIndex is None)) else arg.find("=", startIndex))
                _g11 = HxString.charCodeAt(arg,1)
                _g2 = HxString.charCodeAt(arg,0)
                if (_g2 is None):
                    ret.append(arg)
                elif (_g2 == 45):
                    if (_g11 is None):
                        ret.append(arg)
                    elif (_g11 == 45):
                        i = _g1
                        if (i != -1):
                            x = HxString.substr(arg,0,i)
                            ret.append(x)
                            x1 = HxString.substr(arg,(i + 1),None)
                            ret.append(x1)
                        else:
                            ret.append(arg)
                    else:
                        ret.append(arg)
                else:
                    ret.append(arg)
        return ret



class tink_cli_Router0(tink_cli_Router):
    _hx_class_name = "tink.cli.Router0"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_fields = []
    _hx_methods = ["process", "processFlag", "promptRequired", "run_run"]
    _hx_statics = []
    _hx_interfaces = []
    _hx_super = tink_cli_Router


    def __init__(self,command,prompt):
        super().__init__(command,prompt,True)

    def process(self,args):
        _gthis = self
        if ((args[0] if 0 < len(args) else None) is None):
            args1 = None
            _g = self.processArgs(args)
            args2 = _g.index
            if (args2 == 0):
                args3 = _g.params[0]
                args1 = args3
            elif (args2 == 1):
                f = _g.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f)))
            else:
                pass
            def _hx_local_1():
                def _hx_local_0(_):
                    return _gthis.run_run(args1)
                return tink_core__Promise_Promise_Impl_.next(self.promptRequired(),_hx_local_0)
            return _hx_local_1()
        else:
            args4 = None
            _g1 = self.processArgs(args)
            args5 = _g1.index
            if (args5 == 0):
                args6 = _g1.params[0]
                args4 = args6
            elif (args5 == 1):
                f1 = _g1.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
            def _hx_local_3():
                def _hx_local_2(_1):
                    return _gthis.run_run(args4)
                return tink_core__Promise_Promise_Impl_.next(self.promptRequired(),_hx_local_2)
            return _hx_local_3()

    def processFlag(self,args,index):
        current = index
        _g = (args[index] if index >= 0 and index < len(args) else None)
        _hx_local_0 = len(_g)
        if (_hx_local_0 == 15):
            if (_g == "-include-header"):
                if (self.command.includes is None):
                    self.command.includes = []
                _this1 = self.command.includes
                current = (current + 1)
                x2 = current
                x3 = (args[x2] if x2 >= 0 and x2 < len(args) else None)
                _this1.append(x3)
            else:
                return -1
        elif (_hx_local_0 == 9):
            if (_g == "-lib-path"):
                if (self.command.libPaths is None):
                    self.command.libPaths = []
                _this4 = self.command.libPaths
                current = (current + 1)
                x8 = current
                x9 = (args[x8] if x8 >= 0 and x8 < len(args) else None)
                _this4.append(x9)
            else:
                return -1
        elif (_hx_local_0 == 4):
            if (_g == "-lib"):
                if (self.command.libs is None):
                    self.command.libs = []
                _this3 = self.command.libs
                current = (current + 1)
                x6 = current
                x7 = (args[x6] if x6 >= 0 and x6 < len(args) else None)
                _this3.append(x7)
            elif (_g == "-src"):
                current = (current + 1)
                tmp1 = current
                self.command.src = (args[tmp1] if tmp1 >= 0 and tmp1 < len(args) else None)
            else:
                return -1
        elif (_hx_local_0 == 13):
            if (_g == "-include-path"):
                if (self.command.includePaths is None):
                    self.command.includePaths = []
                _this2 = self.command.includePaths
                current = (current + 1)
                x4 = current
                x5 = (args[x4] if x4 >= 0 and x4 < len(args) else None)
                _this2.append(x5)
            else:
                return -1
        elif (_hx_local_0 == 8):
            if (_g == "-win-api"):
                self.command.winApi = True
            else:
                return -1
        elif (_hx_local_0 == 2):
            if (_g == "-D"):
                if (self.command.defines is None):
                    self.command.defines = []
                _this = self.command.defines
                current = (current + 1)
                x = current
                x1 = (args[x] if x >= 0 and x < len(args) else None)
                _this.append(x1)
            elif (_g == "-o"):
                current = (current + 1)
                tmp = current
                self.command.output = (args[tmp] if tmp >= 0 and tmp < len(args) else None)
            else:
                return -1
        else:
            return -1
        return (current - index)

    def promptRequired(self):
        _gthis = self
        def _hx_local_9():
            def _hx_local_8(cb):
                def _hx_local_2():
                    def _hx_local_0(v):
                        _gthis.command.src = v
                        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
                    return tink_core__Promise_Promise_Impl_.next(_gthis.prompt.prompt(tink_cli_PromptTypeBase.Simple("src")),_hx_local_0) if (_gthis.command.src is None) else tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
                next = _hx_local_2()
                def _hx_local_7(o):
                    tmp = o.index
                    if (tmp == 0):
                        _g = o.params[0]
                        def _hx_local_5():
                            def _hx_local_3(v1):
                                _gthis.command.output = v1
                                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
                            return tink_core__Promise_Promise_Impl_.next(_gthis.prompt.prompt(tink_cli_PromptTypeBase.Simple("o")),_hx_local_3) if (_gthis.command.output is None) else tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
                        next1 = _hx_local_5()
                        def _hx_local_6(o1):
                            tmp1 = o1.index
                            if (tmp1 == 0):
                                _g1 = o1.params[0]
                                cb(tink_core_Outcome.Success(tink_core_Noise.Noise))
                            elif (tmp1 == 1):
                                _g11 = o1.params[0]
                                cb(o1)
                            else:
                                pass
                        next1.handle(_hx_local_6)
                    elif (tmp == 1):
                        _g12 = o.params[0]
                        cb(o)
                    else:
                        pass
                next.handle(_hx_local_7)
            return tink_core__Future_Future_Impl_.make(_hx_local_8)
        return _hx_local_9()

    def run_run(self,args):
        if (len(args) < 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(tink_core_TypedError(None,((("Insufficient arguments. Expected: " + Std.string(0)) + ", Got: ") + Std.string(len(args))),_hx_AnonObject({'fileName': "hxmake/HxMake.hx", 'lineNumber': 65, 'className': "tink.cli.Router0", 'methodName': "run_run"})))))
        self.command.run(args[0:len(args)])
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))



class tink_cli_macro_Router:
    _hx_class_name = "tink.cli.macro.Router"
    _hx_is_interface = "False"
    __slots__ = ()


class tink_cli_prompt_RetryPrompt:
    _hx_class_name = "tink.cli.prompt.RetryPrompt"
    _hx_is_interface = "False"
    __slots__ = ("trials", "proxy")
    _hx_fields = ["trials", "proxy"]
    _hx_methods = ["print", "println", "prompt"]
    _hx_interfaces = [tink_cli_Prompt]

    def __init__(self,trials,proxy = None):
        self.trials = trials
        self.proxy = (tink_cli_prompt_SysPrompt() if ((proxy is None)) else proxy)

    def print(self,v):
        return self.proxy.print(v)

    def println(self,v):
        return self.proxy.println(v)

    def prompt(self,_hx_type):
        _gthis = self
        tmp = _hx_type.index
        if (tmp == 0):
            _g = _hx_type.params[0]
            return self.proxy.prompt(_hx_type)
        elif (tmp == 1):
            c = _hx_type.params[1]
            v = _hx_type.params[0]
            def _hx_local_5():
                def _hx_local_4(cb):
                    remaining = _gthis.trials
                    next = None
                    def _hx_local_3():
                        nonlocal remaining
                        remaining = (remaining - 1)
                        def _hx_local_1():
                            if (remaining > 0):
                                next()
                            else:
                                retry1 = tink_core_Outcome.Failure(tink_core_TypedError(None,"Maximum retries reached",_hx_AnonObject({'fileName': "tink/cli/prompt/RetryPrompt.hx", 'lineNumber': 36, 'className': "tink.cli.prompt.RetryPrompt", 'methodName': "prompt"})))
                                cb(retry1)
                        retry = _hx_local_1
                        def _hx_local_2(o):
                            next1 = o.index
                            if (next1 == 0):
                                result = o.params[0]
                                if (python_internal_ArrayImpl.indexOf(c,result,None) == -1):
                                    retry()
                                else:
                                    cb(tink_core_Outcome.Success(result))
                            elif (next1 == 1):
                                f = o.params[0]
                                retry()
                            else:
                                pass
                        _gthis.proxy.prompt(_hx_type).handle(_hx_local_2)
                    next = _hx_local_3
                    next()
                return tink_core__Future_Future_Impl_.make(_hx_local_4)
            return _hx_local_5()
        elif (tmp == 2):
            _g3 = _hx_type.params[0]
            return self.proxy.prompt(_hx_type)
        else:
            pass



class tink_cli_prompt_SysPrompt:
    _hx_class_name = "tink.cli.prompt.SysPrompt"
    _hx_is_interface = "False"
    __slots__ = ("worker",)
    _hx_fields = ["worker"]
    _hx_methods = ["print", "println", "prompt"]
    _hx_interfaces = [tink_cli_Prompt]

    def __init__(self,worker = None):
        self.worker = tink_io__Worker_Worker_Impl_.ensure(worker)

    def print(self,v):
        def _hx_local_1():
            def _hx_local_0():
                python_Lib.printString(Std.string(v))
                return tink_core_Outcome.Success(tink_core_Noise.Noise)
            return tink_io__Worker_Worker_Impl_.work(self.worker,tink_core__Lazy_LazyFunc(_hx_local_0))
        return _hx_local_1()

    def println(self,v):
        def _hx_local_1():
            def _hx_local_0():
                _hx_str = Std.string(v)
                python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                return tink_core_Outcome.Success(tink_core_Noise.Noise)
            return tink_io__Worker_Worker_Impl_.work(self.worker,tink_core__Lazy_LazyFunc(_hx_local_0))
        return _hx_local_1()

    def prompt(self,_hx_type):
        def _hx_local_1():
            def _hx_local_0():
                tmp = _hx_type.index
                if (tmp == 0):
                    v = _hx_type.params[0]
                    python_Lib.printString(Std.string((("" + ("null" if v is None else v)) + ": ")))
                    return tink_core_Outcome.Success(Sys.stdin().readLine())
                elif (tmp == 1):
                    c = _hx_type.params[1]
                    v1 = _hx_type.params[0]
                    python_Lib.printString(Std.string((((("" + ("null" if v1 is None else v1)) + " [") + HxOverrides.stringOrNull("/".join([python_Boot.toString1(x1,'') for x1 in c]))) + "]: ")))
                    return tink_core_Outcome.Success(Sys.stdin().readLine())
                elif (tmp == 2):
                    v2 = _hx_type.params[0]
                    python_Lib.printString(Std.string((("" + ("null" if v2 is None else v2)) + ": ")))
                    s = []
                    while True:
                        _g = Sys.getChar(False)
                        _g1 = _g
                        if ((_g1 == 4) or ((_g1 == 3))):
                            _hx_str = ""
                            python_Lib.printString((("" + ("null" if _hx_str is None else _hx_str)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                            Sys.exit(1)
                        elif ((_g1 == 13) or ((_g1 == 10))):
                            str1 = ""
                            python_Lib.printString((("" + ("null" if str1 is None else str1)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                            break
                        elif (_g1 == 127):
                            if (len(s) != 0):
                                s.pop()
                        else:
                            c1 = _g
                            if (c1 >= 32):
                                s.append(c1)
                            else:
                                c2 = _g
                                str2 = ""
                                python_Lib.printString((("" + ("null" if str2 is None else str2)) + HxOverrides.stringOrNull(python_Lib.lineEnd)))
                                return tink_core_Outcome.Failure(tink_core_TypedError(None,("Invalid char " + Std.string(c2)),_hx_AnonObject({'fileName': "tink/cli/prompt/SysPrompt.hx", 'lineNumber': 54, 'className': "tink.cli.prompt.SysPrompt", 'methodName': "prompt"})))
                    _this = list(map(_String_String_Impl_.fromCharCode,s))
                    return tink_core_Outcome.Success("".join([python_Boot.toString1(x1,'') for x1 in _this]))
                else:
                    pass
            return tink_core__Promise_Promise_Impl_.ofSpecific(tink_io__Worker_Worker_Impl_.work(self.worker,tink_core__Lazy_LazyFunc(_hx_local_0)))
        return _hx_local_1()



class tink_core_Annex:
    _hx_class_name = "tink.core.Annex"
    _hx_is_interface = "False"
    __slots__ = ("target", "registry")
    _hx_fields = ["target", "registry"]

    def __init__(self,target):
        self.target = target
        self.registry = haxe_ds_ObjectMap()



class tink_core__Callback_Callback_Impl_:
    _hx_class_name = "tink.core._Callback.Callback_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "toFunction", "depth", "MAX_DEPTH", "invoke", "ignore", "fromNiladic", "fromMany", "defer"]

    @staticmethod
    def _new(f):
        this1 = f
        return this1

    @staticmethod
    def toFunction(this1):
        return this1

    @staticmethod
    def invoke(this1,data):
        if (tink_core__Callback_Callback_Impl_.depth < 200):
            _hx_local_0 = tink_core__Callback_Callback_Impl_
            _hx_local_1 = _hx_local_0.depth
            _hx_local_0.depth = (_hx_local_1 + 1)
            _hx_local_1
            this1(data)
            _hx_local_2 = tink_core__Callback_Callback_Impl_
            _hx_local_3 = _hx_local_2.depth
            _hx_local_2.depth = (_hx_local_3 - 1)
            _hx_local_3
        else:
            _e = this1
            def _hx_local_4(data1):
                tink_core__Callback_Callback_Impl_.invoke(_e,data1)
            f = _hx_local_4
            data2 = data
            def _hx_local_5():
                f(data2)
            tink_core__Callback_Callback_Impl_.defer(_hx_local_5)

    @staticmethod
    def ignore(cb):
        def _hx_local_0(_):
            tink_core__Callback_Callback_Impl_.invoke(cb,tink_core_Noise.Noise)
        return _hx_local_0

    @staticmethod
    def fromNiladic(f):
        def _hx_local_0(_):
            f()
        return _hx_local_0

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_0(v):
            _g = 0
            while (_g < len(callbacks)):
                callback = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                _g = (_g + 1)
                tink_core__Callback_Callback_Impl_.invoke(callback,v)
        return _hx_local_0

    @staticmethod
    def defer(f):
        haxe_Timer.delay(f,0)


class tink_core_LinkObject:
    _hx_class_name = "tink.core.LinkObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["cancel"]


class tink_core__Callback_CallbackLink_Impl_:
    _hx_class_name = "tink.core._Callback.CallbackLink_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "cancel", "dissolve", "noop", "toFunction", "toCallback", "fromFunction", "join", "fromMany"]

    @staticmethod
    def _new(link):
        this1 = tink_core_SimpleLink(link)
        return this1

    @staticmethod
    def cancel(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def dissolve(this1):
        if (this1 is not None):
            this1.cancel()

    @staticmethod
    def noop():
        pass

    @staticmethod
    def toFunction(this1):
        if (this1 is None):
            return tink_core__Callback_CallbackLink_Impl_.noop
        else:
            return this1.cancel

    @staticmethod
    def toCallback(this1):
        def _hx_local_0(_):
            this1.cancel()
        return _hx_local_0

    @staticmethod
    def fromFunction(f):
        this1 = tink_core_SimpleLink(f)
        return this1

    @staticmethod
    def join(a,b):
        return tink_core__Callback_LinkPair(a,b)

    @staticmethod
    def fromMany(callbacks):
        def _hx_local_1():
            nonlocal callbacks
            if (callbacks is not None):
                _g = 0
                while (_g < len(callbacks)):
                    cb = (callbacks[_g] if _g >= 0 and _g < len(callbacks) else None)
                    _g = (_g + 1)
                    if (cb is not None):
                        cb.cancel()
            else:
                callbacks = None
        this1 = tink_core_SimpleLink(_hx_local_1)
        return this1


class tink_core_SimpleLink:
    _hx_class_name = "tink.core.SimpleLink"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,f):
        self.f = f

    def cancel(self):
        if (self.f is not None):
            self.f()
            self.f = None



class tink_core__Callback_LinkPair:
    _hx_class_name = "tink.core._Callback.LinkPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b", "dissolved")
    _hx_fields = ["a", "b", "dissolved"]
    _hx_methods = ["cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,a,b):
        self.dissolved = False
        self.a = a
        self.b = b

    def cancel(self):
        if (not self.dissolved):
            self.dissolved = True
            this1 = self.a
            if (this1 is not None):
                this1.cancel()
            this2 = self.b
            if (this2 is not None):
                this2.cancel()
            self.a = None
            self.b = None



class tink_core__Callback_ListCell:
    _hx_class_name = "tink.core._Callback.ListCell"
    _hx_is_interface = "False"
    __slots__ = ("cb", "list")
    _hx_fields = ["cb", "list"]
    _hx_methods = ["invoke", "clear", "cancel"]
    _hx_interfaces = [tink_core_LinkObject]

    def __init__(self,cb,_hx_list):
        if (cb is None):
            raise _HxException("callback expected but null received")
        self.cb = cb
        self.list = _hx_list

    def invoke(self,data):
        if (self.list is not None):
            tink_core__Callback_Callback_Impl_.invoke(self.cb,data)

    def clear(self):
        self.cb = None
        self.list = None

    def cancel(self):
        if (self.list is not None):
            _hx_list = self.list
            self.cb = None
            self.list = None
            def _hx_local_1():
                _hx_list.used = (_hx_list.used - 1)
                return _hx_list.used
            tmp = _hx_local_1()
            if (tmp < ((_hx_list.used >> 1))):
                _hx_list.compact()



class tink_core_CallbackList:
    _hx_class_name = "tink.core.CallbackList"
    _hx_is_interface = "False"
    _hx_fields = ["cells", "used", "queue", "busy"]
    _hx_methods = ["ondrain", "get_length", "release", "add", "invoke", "compact", "resize", "clear"]

    def __init__(self):
        self.busy = False
        self.queue = []
        self.used = 0
        self.cells = []

    def ondrain(self):
        pass

    def get_length(self):
        return self.used

    def release(self):
        self.used = (self.used - 1)
        tmp = self.used
        if (tmp < ((self.used >> 1))):
            self.compact()

    def add(self,cb):
        node = tink_core__Callback_ListCell(cb,self)
        _this = self.cells
        _this.append(node)
        _hx_local_0 = self
        _hx_local_1 = _hx_local_0.used
        _hx_local_0.used = (_hx_local_1 + 1)
        _hx_local_1
        return node

    def invoke(self,data,destructive = None):
        if self.busy:
            _this = self.queue
            f = self.invoke
            data1 = data
            destructive1 = destructive
            def _hx_local_0():
                f(data1,destructive1)
                return
            tmp = _hx_local_0
            _this.append(tmp)
        else:
            self.busy = True
            length = len(self.cells)
            _g = 0
            _g1 = length
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _this1 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                if (_this1.list is not None):
                    tink_core__Callback_Callback_Impl_.invoke(_this1.cb,data)
            self.busy = False
            if destructive:
                added = (len(self.cells) - length)
                _g2 = 0
                _g3 = length
                while (_g2 < _g3):
                    i1 = _g2
                    _g2 = (_g2 + 1)
                    _this2 = (self.cells[i1] if i1 >= 0 and i1 < len(self.cells) else None)
                    _this2.cb = None
                    _this2.list = None
                _g4 = 0
                _g5 = added
                while (_g4 < _g5):
                    i2 = _g4
                    _g4 = (_g4 + 1)
                    python_internal_ArrayImpl._set(self.cells, i2, python_internal_ArrayImpl._get(self.cells, (length + i2)))
                self.resize(added)
            elif (self.used < len(self.cells)):
                self.compact()
            if (len(self.queue) > 0):
                _this3 = self.queue
                ((None if ((len(_this3) == 0)) else _this3.pop(0)))()

    def compact(self):
        if self.busy:
            return
        elif (self.used == 0):
            self.resize(0)
            self.ondrain()
        else:
            compacted = 0
            _g = 0
            _g1 = len(self.cells)
            while (_g < _g1):
                i = _g
                _g = (_g + 1)
                _g2 = (self.cells[i] if i >= 0 and i < len(self.cells) else None)
                _g21 = _g2.list
                if (_g2.cb is not None):
                    v = _g2
                    if (compacted != i):
                        python_internal_ArrayImpl._set(self.cells, compacted, v)
                    compacted = (compacted + 1)
                    tmp = compacted
                    if (tmp == self.used):
                        break
            self.resize(self.used)

    def resize(self,length):
        _this = self.cells
        l = len(_this)
        if (l < length):
            idx = (length - 1)
            v = None
            l1 = len(_this)
            while (l1 < idx):
                _this.append(None)
                l1 = (l1 + 1)
            if (l1 == idx):
                _this.append(v)
            else:
                _this[idx] = v
        elif (l > length):
            pos = length
            _hx_len = (l - length)
            if (pos < 0):
                pos = (len(_this) + pos)
            if (pos < 0):
                pos = 0
            res = _this[pos:(pos + _hx_len)]
            del _this[pos:(pos + _hx_len)]

    def clear(self):
        if self.busy:
            _this = self.queue
            _this.append(self.clear)
        _g = 0
        _g1 = self.cells
        while (_g < len(_g1)):
            cell = (_g1[_g] if _g >= 0 and _g < len(_g1) else None)
            _g = (_g + 1)
            cell.cb = None
            cell.list = None
        self.resize(0)



class tink_core_TypedError:
    _hx_class_name = "tink.core.TypedError"
    _hx_is_interface = "False"
    __slots__ = ("message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError")
    _hx_fields = ["message", "code", "data", "pos", "callStack", "exceptionStack", "isTinkError"]
    _hx_methods = ["printPos", "toString", "throwSelf"]
    _hx_statics = ["withData", "typed", "asError", "catchExceptions", "reporter", "rethrow", "tryFinally"]

    def __init__(self,code = None,message = None,pos = None):
        if (code is None):
            code = 500
        self.data = None
        self.isTinkError = True
        self.code = code
        self.message = message
        self.pos = pos
        self.exceptionStack = []
        self.callStack = []

    def printPos(self):
        return ((((HxOverrides.stringOrNull(self.pos.className) + ".") + HxOverrides.stringOrNull(self.pos.methodName)) + ":") + Std.string(self.pos.lineNumber))

    def toString(self):
        ret = ((("Error#" + Std.string(self.code)) + ": ") + HxOverrides.stringOrNull(self.message))
        if (self.pos is not None):
            ret = (("null" if ret is None else ret) + HxOverrides.stringOrNull(((" @ " + HxOverrides.stringOrNull(self.printPos())))))
        return ret

    def throwSelf(self):
        any = self
        raise _HxException(any)

    @staticmethod
    def withData(code = None,message = None,data = None,pos = None):
        return tink_core_TypedError.typed(code,message,data,pos)

    @staticmethod
    def typed(code = None,message = None,data = None,pos = None):
        ret = tink_core_TypedError(code,message,pos)
        ret.data = data
        return ret

    @staticmethod
    def asError(v):
        return Std.downcast(v,tink_core_TypedError)

    @staticmethod
    def catchExceptions(f,report = None,pos = None):
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            _g = tink_core_TypedError.asError(e)
            tmp = None
            if (_g is None):
                tmp = (tink_core_TypedError.withData(None,"Unexpected Error",e,pos) if ((report is None)) else report(e))
            else:
                e1 = _g
                tmp = e1
            return tink_core_Outcome.Failure(tmp)

    @staticmethod
    def reporter(code = None,message = None,pos = None):
        def _hx_local_0(e):
            return tink_core_TypedError.withData(code,message,e,pos)
        return _hx_local_0

    @staticmethod
    def rethrow(any):
        raise _HxException(any)

    @staticmethod
    def tryFinally(f,cleanup):
        try:
            ret = f()
            cleanup()
            return ret
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            cleanup()
            raise _HxException(e)



class tink_core__Error_Stack_Impl_:
    _hx_class_name = "tink.core._Error.Stack_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["toString"]

    @staticmethod
    def toString(this1):
        return "Error stack not available. Compile with -D error_stack."


class tink_core__Future_FutureObject:
    _hx_class_name = "tink.core._Future.FutureObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]


class tink_core__Future_NeverFuture:
    _hx_class_name = "tink.core._Future.NeverFuture"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["map", "flatMap", "handle", "gather", "eager"]
    _hx_statics = ["inst"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self):
        pass

    def map(self,f):
        return tink_core__Future_NeverFuture.inst

    def flatMap(self,f):
        return tink_core__Future_NeverFuture.inst

    def handle(self,callback):
        return None

    def gather(self):
        return tink_core__Future_NeverFuture.inst

    def eager(self):
        return tink_core__Future_NeverFuture.inst


class tink_core_Noise(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Noise"
tink_core_Noise.Noise = tink_core_Noise("Noise", 0, ())


class tink_core__Lazy_LazyObject:
    _hx_class_name = "tink.core._Lazy.LazyObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["get", "map", "flatMap"]


class tink_core__Lazy_LazyConst:
    _hx_class_name = "tink.core._Lazy.LazyConst"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,value):
        self.value = value

    def get(self):
        return self.value

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                return f(_gthis.value).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()



class tink_core__Future_SyncFuture:
    _hx_class_name = "tink.core._Future.SyncFuture"
    _hx_is_interface = "False"
    __slots__ = ("value",)
    _hx_fields = ["value"]
    _hx_methods = ["map", "flatMap", "handle", "eager", "gather"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self,value):
        self.value = value

    def map(self,f):
        return tink_core__Future_SyncFuture(self.value.map(f))

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0(_hx_yield):
                tmp = _gthis.value.get()
                return f(tmp).handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()

    def handle(self,cb):
        tink_core__Callback_Callback_Impl_.invoke(cb,self.value.get())
        return None

    def eager(self):
        return self

    def gather(self):
        return self



class tink_core__Future_Future_Impl_:
    _hx_class_name = "tink.core._Future.Future_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "first", "map", "flatMap", "next", "merge", "flatten", "ofAny", "asPromise", "ofMany", "fromMany", "lazy", "sync", "make", "or", "either", "and", "_tryFailingFlatMap", "_tryFlatMap", "_tryFailingMap", "_tryMap", "_flatMap", "_map", "trigger", "delay"]

    @staticmethod
    def _new(f):
        this1 = tink_core__Future_SuspendableFuture(f)
        return this1

    @staticmethod
    def first(this1,other):
        ret = tink_core_FutureTrigger()
        l1 = this1.handle(ret.trigger)
        l2 = other.handle(ret.trigger)
        ret1 = ret
        if (l1 is not None):
            this2 = l1
            def _hx_local_0(_):
                this2.cancel()
            ret1.handle(_hx_local_0)
        if (l2 is not None):
            this3 = l2
            def _hx_local_1(_1):
                this3.cancel()
            ret1.handle(_hx_local_1)
        return ret1

    @staticmethod
    def map(this1,f,gather = None):
        if (gather is None):
            gather = True
        ret = this1.map(f)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatMap(this1,next,gather = None):
        if (gather is None):
            gather = True
        ret = this1.flatMap(next)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def next(this1,n):
        def _hx_local_1():
            def _hx_local_0(v):
                return n(v)
            return this1.flatMap(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        if (gather is None):
            gather = True
        gather1 = gather
        if (gather1 is None):
            gather1 = True
        def _hx_local_1(t):
            gather2 = False
            if (gather2 is None):
                gather2 = True
            def _hx_local_0(a):
                return merger(t,a)
            ret1 = other.map(_hx_local_0)
            if gather2:
                return ret1.gather()
            else:
                return ret1
        ret = this1.flatMap(_hx_local_1)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def flatten(f):
        def _hx_local_3():
            def _hx_local_2(_hx_yield):
                inner = None
                def _hx_local_0(second):
                    nonlocal inner
                    inner = second.handle(_hx_yield)
                outer = f.handle(_hx_local_0)
                def _hx_local_1():
                    if (inner is not None):
                        inner.cancel()
                this1 = tink_core_SimpleLink(_hx_local_1)
                return tink_core__Callback_LinkPair(outer,this1)
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    @staticmethod
    def ofAny(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def asPromise(s):
        return s

    @staticmethod
    def ofMany(futures,gather = None):
        if (gather is None):
            gather = True
        ret = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst([]))
        _g = 0
        while (_g < len(futures)):
            f = [(futures[_g] if _g >= 0 and _g < len(futures) else None)]
            _g = (_g + 1)
            gather1 = False
            if (gather1 is None):
                gather1 = True
            def _hx_local_4(f1):
                def _hx_local_1(results):
                    gather2 = False
                    if (gather2 is None):
                        gather2 = True
                    def _hx_local_3():
                        def _hx_local_2(result):
                            return (results + [result])
                        return _hx_local_2
                    ret2 = _hx_local_3()
                    ret3 = (f1[0] if 0 < len(f1) else None).map(ret2)
                    if gather2:
                        return ret3.gather()
                    else:
                        return ret3
                return _hx_local_1
            ret1 = ret.flatMap(_hx_local_4(f))
            ret = (ret1.gather() if gather1 else ret1)
        if gather:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def fromMany(futures):
        return tink_core__Future_Future_Impl_.ofMany(futures)

    @staticmethod
    def lazy(l):
        return tink_core__Future_SyncFuture(l)

    @staticmethod
    def sync(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(v))

    @staticmethod
    def make(f,lazy = None):
        if (lazy is None):
            lazy = False
        if lazy:
            def _hx_local_1():
                def _hx_local_0(_hx_yield):
                    f(_hx_yield)
                    return None
                return tink_core__Future_SuspendableFuture(_hx_local_0)
            return _hx_local_1()
        else:
            op = tink_core_FutureTrigger()
            wrapped = f
            tink_core__Callback_Callback_Impl_.invoke(wrapped,op.trigger)
            return op

    @staticmethod
    def _hx_or(a,b):
        return tink_core__Future_Future_Impl_.first(a,b)

    @staticmethod
    def either(a,b):
        gather = False
        if (gather is None):
            gather = True
        ret = a.map(haxe_ds_Either.Left)
        tmp = (ret.gather() if gather else ret)
        gather1 = False
        if (gather1 is None):
            gather1 = True
        ret1 = b.map(haxe_ds_Either.Right)
        return tink_core__Future_Future_Impl_.first(tmp,(ret1.gather() if gather1 else ret1))

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a1,b1):
                this1 = tink_core_MPair(a1,b1)
                return this1
            return tink_core__Future_Future_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def _tryFailingFlatMap(f,_hx_map):
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                d = o.params[0]
                return _hx_map(d)
            elif (ret1 == 1):
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFlatMap(f,_hx_map):
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                d = o.params[0]
                ret2 = _hx_map(d).map(tink_core_Outcome.Success)
                return ret2.gather()
            elif (ret1 == 1):
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = f.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryFailingMap(f,_hx_map):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.flatMap(o,tink_core__Outcome_OutcomeMapper_Impl_.withSameError(_hx_map))
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _tryMap(f,_hx_map):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.map(o,_hx_map)
        ret = f.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def _flatMap(f,_hx_map):
        ret = f.flatMap(_hx_map)
        return ret.gather()

    @staticmethod
    def _map(f,_hx_map):
        ret = f.map(_hx_map)
        return ret.gather()

    @staticmethod
    def trigger():
        return tink_core_FutureTrigger()

    @staticmethod
    def delay(ms,value):
        def _hx_local_2():
            def _hx_local_1(cb):
                def _hx_local_0():
                    cb(value.get())
                haxe_Timer.delay(_hx_local_0,ms)
            return tink_core__Future_Future_Impl_.make(_hx_local_1)
        return _hx_local_2()


class tink_core_FutureTrigger:
    _hx_class_name = "tink.core.FutureTrigger"
    _hx_is_interface = "False"
    __slots__ = ("result", "list")
    _hx_fields = ["result", "list"]
    _hx_methods = ["handle", "map", "flatMap", "gather", "eager", "asFuture", "trigger"]
    _hx_statics = ["gatherFuture"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self):
        self.result = None
        self.list = tink_core_CallbackList()

    def handle(self,callback):
        _g = self.list
        if (_g is None):
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            return None
        else:
            v = _g
            node = tink_core__Callback_ListCell(callback,v)
            _this = v.cells
            _this.append(node)
            v.used = (v.used + 1)
            return node

    def map(self,f):
        _g = self.list
        if (_g is None):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(self.result)))
        else:
            v = _g
            ret = tink_core_FutureTrigger()
            _this = self.list
            def _hx_local_0(v1):
                node1 = f(v1)
                ret.trigger(node1)
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            return ret

    def flatMap(self,f):
        _g = self.list
        if (_g is None):
            return f(self.result)
        else:
            v = _g
            ret = tink_core_FutureTrigger()
            _this = self.list
            def _hx_local_0(v1):
                f(v1).handle(ret.trigger)
            node = tink_core__Callback_ListCell(_hx_local_0,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            return ret

    def gather(self):
        return self

    def eager(self):
        return self

    def asFuture(self):
        return self

    def trigger(self,result):
        if (self.list is None):
            return False
        else:
            _hx_list = self.list
            self.list = None
            self.result = result
            _hx_list.invoke(result,True)
            return True

    @staticmethod
    def gatherFuture(f):
        def _hx_local_1():
            def _hx_local_0(_hx_yield):
                return f.handle(_hx_yield)
            return tink_core__Future_SuspendableFuture(_hx_local_0)
        return _hx_local_1()



class tink_core__Future_SuspendableFuture:
    _hx_class_name = "tink.core._Future.SuspendableFuture"
    _hx_is_interface = "False"
    __slots__ = ("callbacks", "result", "suspended", "link", "wakeup")
    _hx_fields = ["callbacks", "result", "suspended", "link", "wakeup"]
    _hx_methods = ["trigger", "handle", "map", "flatMap", "gather", "eager"]
    _hx_interfaces = [tink_core__Future_FutureObject]

    def __init__(self,wakeup):
        self.wakeup = None
        self.link = None
        self.result = None
        self.callbacks = None
        self.suspended = True
        _gthis = self
        self.wakeup = wakeup
        self.callbacks = tink_core_CallbackList()
        def _hx_local_0():
            if (_gthis.callbacks is not None):
                _gthis.suspended = True
                this1 = _gthis.link
                if (this1 is not None):
                    this1.cancel()
                _gthis.link = None
        self.callbacks.ondrain = _hx_local_0

    def trigger(self,value):
        _g = self.callbacks
        if (_g is not None):
            _hx_list = _g
            self.callbacks = None
            self.suspended = False
            self.result = value
            self.link = None
            self.wakeup = None
            _hx_list.invoke(value,True)

    def handle(self,callback):
        _g = self.callbacks
        if (_g is None):
            tink_core__Callback_Callback_Impl_.invoke(callback,self.result)
            return None
        else:
            v = _g
            _this = self.callbacks
            node = tink_core__Callback_ListCell(callback,_this)
            _this1 = _this.cells
            _this1.append(node)
            _this.used = (_this.used + 1)
            ret = node
            if self.suspended:
                self.suspended = False
                self.link = self.wakeup(self.trigger)
            return ret

    def map(self,f):
        _gthis = self
        def _hx_local_3():
            def _hx_local_2(_hx_yield):
                def _hx_local_1():
                    def _hx_local_0(res):
                        tmp = f(res)
                        _hx_yield(tmp)
                    return _gthis.handle(_hx_local_0)
                return _hx_local_1()
            return tink_core__Future_SuspendableFuture(_hx_local_2)
        return _hx_local_3()

    def flatMap(self,f):
        return tink_core__Future_Future_Impl_.flatten(self.map(f))

    def gather(self):
        return self

    def eager(self):
        def _hx_local_0():
            pass
        self.handle(tink_core__Callback_Callback_Impl_.fromNiladic(_hx_local_0))
        return self



class tink_core__Lazy_Lazy_Impl_:
    _hx_class_name = "tink.core._Lazy.Lazy_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "get", "ofFunc", "map", "flatMap", "ofConst"]

    @staticmethod
    def get(this1):
        return this1.get()

    @staticmethod
    def ofFunc(f):
        return tink_core__Lazy_LazyFunc(f)

    @staticmethod
    def map(this1,f):
        return this1.map(f)

    @staticmethod
    def flatMap(this1,f):
        return this1.flatMap(f)

    @staticmethod
    def ofConst(c):
        return tink_core__Lazy_LazyConst(c)


class tink_core__Lazy_LazyFunc:
    _hx_class_name = "tink.core._Lazy.LazyFunc"
    _hx_is_interface = "False"
    __slots__ = ("f", "result")
    _hx_fields = ["f", "result"]
    _hx_methods = ["get", "map", "flatMap"]
    _hx_interfaces = [tink_core__Lazy_LazyObject]

    def __init__(self,f):
        self.result = None
        self.f = f

    def get(self):
        if (self.f is not None):
            self.result = self.f()
            self.f = None
        return self.result

    def map(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                tmp = _gthis.get()
                return f(tmp)
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()

    def flatMap(self,f):
        _gthis = self
        def _hx_local_1():
            def _hx_local_0():
                this1 = _gthis.get()
                return f(this1).get()
            return tink_core__Lazy_LazyFunc(_hx_local_0)
        return _hx_local_1()



class tink_core_NamedWith:
    _hx_class_name = "tink.core.NamedWith"
    _hx_is_interface = "False"
    __slots__ = ("name", "value")
    _hx_fields = ["name", "value"]

    def __init__(self,name,value):
        self.name = name
        self.value = value



class tink_core_OptionTools:
    _hx_class_name = "tink.core.OptionTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["force", "or", "orNull", "filter", "satisfies", "equals", "map", "flatMap", "iterator", "toArray"]

    @staticmethod
    def force(o,pos = None):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            raise _HxException(tink_core_TypedError(404,"Some value expected but none found",pos))

    @staticmethod
    def _hx_or(o,l):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return l.get()

    @staticmethod
    def orNull(o):
        if (o.index == 0):
            v = o.params[0]
            return v
        else:
            return None

    @staticmethod
    def filter(o,f):
        if (o.index == 0):
            if (f(o.params[0]) == False):
                return haxe_ds_Option._hx_None
            else:
                return o
        else:
            return o

    @staticmethod
    def satisfies(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return False

    @staticmethod
    def equals(o,v):
        if (o.index == 0):
            v1 = o.params[0]
            return HxOverrides.eq(v1,v)
        else:
            return False

    @staticmethod
    def map(o,f):
        if (o.index == 0):
            v = o.params[0]
            return haxe_ds_Option.Some(f(v))
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def flatMap(o,f):
        if (o.index == 0):
            v = o.params[0]
            return f(v)
        else:
            return haxe_ds_Option._hx_None

    @staticmethod
    def iterator(o):
        return tink_core_OptionIter(o)

    @staticmethod
    def toArray(o):
        if (o.index == 0):
            v = o.params[0]
            return [v]
        else:
            return []


class tink_core_OptionIter:
    _hx_class_name = "tink.core.OptionIter"
    _hx_is_interface = "False"
    __slots__ = ("value", "alive")
    _hx_fields = ["value", "alive"]
    _hx_methods = ["hasNext", "next"]

    def __init__(self,o):
        self.value = None
        self.alive = True
        if (o.index == 0):
            v = o.params[0]
            self.value = v
        else:
            self.alive = False

    def hasNext(self):
        return self.alive

    def next(self):
        self.alive = False
        return self.value


class tink_core_Outcome(Enum):
    __slots__ = ()
    _hx_class_name = "tink.core.Outcome"

    @staticmethod
    def Success(data):
        return tink_core_Outcome("Success", 0, (data,))

    @staticmethod
    def Failure(failure):
        return tink_core_Outcome("Failure", 1, (failure,))


class tink_core_OutcomeTools:
    _hx_class_name = "tink.core.OutcomeTools"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["sure", "toOption", "toOutcome", "orNull", "orUse", "orTry", "equals", "map", "isSuccess", "flatMap", "swap", "next", "attempt", "flatten"]

    @staticmethod
    def sure(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            failure = outcome.params[0]
            _g = tink_core_TypedError.asError(failure)
            if (_g is None):
                raise _HxException(failure)
            else:
                e = _g
                return e.throwSelf()
        else:
            pass

    @staticmethod
    def toOption(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return haxe_ds_Option.Some(data)
        elif (tmp == 1):
            _g1 = outcome.params[0]
            return haxe_ds_Option._hx_None
        else:
            pass

    @staticmethod
    def toOutcome(option,pos = None):
        tmp = option.index
        if (tmp == 0):
            value = option.params[0]
            return tink_core_Outcome.Success(value)
        elif (tmp == 1):
            return tink_core_Outcome.Failure(tink_core_TypedError(404,((("Some value expected but none found in " + HxOverrides.stringOrNull(pos.fileName)) + "@line ") + Std.string(pos.lineNumber)),_hx_AnonObject({'fileName': "tink/core/Outcome.hx", 'lineNumber': 48, 'className': "tink.core.OutcomeTools", 'methodName': "toOutcome"})))
        else:
            pass

    @staticmethod
    def orNull(outcome):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g1 = outcome.params[0]
            return None
        else:
            pass

    @staticmethod
    def orUse(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return data
        elif (tmp == 1):
            _g1 = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def orTry(outcome,fallback):
        tmp = outcome.index
        if (tmp == 0):
            _g = outcome.params[0]
            return outcome
        elif (tmp == 1):
            _g1 = outcome.params[0]
            return fallback.get()
        else:
            pass

    @staticmethod
    def equals(outcome,to):
        tmp = outcome.index
        if (tmp == 0):
            data = outcome.params[0]
            return HxOverrides.eq(data,to)
        elif (tmp == 1):
            _g1 = outcome.params[0]
            return False
        else:
            pass

    @staticmethod
    def map(outcome,transform):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(transform(a))
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def isSuccess(outcome):
        if (outcome.index == 0):
            _g = outcome.params[0]
            return True
        else:
            return False

    @staticmethod
    def flatMap(o,mapper):
        return tink_core__Outcome_OutcomeMapper_Impl_.apply(mapper,o)

    @staticmethod
    def swap(outcome,v):
        tmp = outcome.index
        if (tmp == 0):
            a = outcome.params[0]
            return tink_core_Outcome.Success(v)
        elif (tmp == 1):
            f = outcome.params[0]
            return tink_core_Outcome.Failure(f)
        else:
            pass

    @staticmethod
    def next(outcome,f):
        tmp = outcome.index
        if (tmp == 0):
            v = outcome.params[0]
            return f(v)
        elif (tmp == 1):
            e = outcome.params[0]
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))
        else:
            pass

    @staticmethod
    def attempt(f,report):
        try:
            return tink_core_Outcome.Success(f())
        except Exception as _hx_e:
            _hx_e1 = _hx_e.val if isinstance(_hx_e, _HxException) else _hx_e
            e = _hx_e1
            return tink_core_Outcome.Failure(report(e))

    @staticmethod
    def flatten(o):
        tmp = o.index
        if (tmp == 0):
            _g = o.params[0]
            tmp1 = _g.index
            if (tmp1 == 0):
                d = _g.params[0]
                return tink_core_Outcome.Success(d)
            elif (tmp1 == 1):
                f = _g.params[0]
                return tink_core_Outcome.Failure(f)
            else:
                pass
        elif (tmp == 1):
            f1 = o.params[0]
            return tink_core_Outcome.Failure(f1)
        else:
            pass


class tink_core__Outcome_OutcomeMapper_Impl_:
    _hx_class_name = "tink.core._Outcome.OutcomeMapper_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "apply", "withSameError", "withEitherError"]

    @staticmethod
    def _new(f):
        this1 = _hx_AnonObject({'f': f})
        return this1

    @staticmethod
    def apply(this1,o):
        return this1.f(o)

    @staticmethod
    def withSameError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    return f(d)
                elif (tmp == 1):
                    f1 = o.params[0]
                    return tink_core_Outcome.Failure(f1)
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def withEitherError(f):
        def _hx_local_1():
            def _hx_local_0(o):
                tmp = o.index
                if (tmp == 0):
                    d = o.params[0]
                    _g = f(d)
                    tmp1 = _g.index
                    if (tmp1 == 0):
                        d1 = _g.params[0]
                        return tink_core_Outcome.Success(d1)
                    elif (tmp1 == 1):
                        f1 = _g.params[0]
                        return tink_core_Outcome.Failure(haxe_ds_Either.Right(f1))
                    else:
                        pass
                elif (tmp == 1):
                    f2 = o.params[0]
                    return tink_core_Outcome.Failure(haxe_ds_Either.Left(f2))
                else:
                    pass
            return tink_core__Outcome_OutcomeMapper_Impl_._new(_hx_local_0)
        return _hx_local_1()


class tink_core__Pair_Pair_Impl_:
    _hx_class_name = "tink.core._Pair.Pair_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_a", "get_b", "toBool", "isNil", "nil"]
    a = None
    b = None

    @staticmethod
    def _new(a,b):
        this1 = tink_core_MPair(a,b)
        return this1

    @staticmethod
    def get_a(this1):
        return this1.a

    @staticmethod
    def get_b(this1):
        return this1.b

    @staticmethod
    def toBool(this1):
        return (this1 is not None)

    @staticmethod
    def isNil(this1):
        return (this1 is None)

    @staticmethod
    def nil():
        return None


class tink_core_MPair:
    _hx_class_name = "tink.core.MPair"
    _hx_is_interface = "False"
    __slots__ = ("a", "b")
    _hx_fields = ["a", "b"]

    def __init__(self,a,b):
        self.a = a
        self.b = b



class tink_core__Promise_Promise_Impl_:
    _hx_class_name = "tink.core._Promise.Promise_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["NULL", "NOISE", "NEVER", "_new", "eager", "map", "flatMap", "tryRecover", "recover", "mapError", "handle", "noise", "isSuccess", "next", "swap", "swapError", "merge", "and", "iterate", "retry", "ofSpecific", "ofFuture", "ofOutcome", "ofError", "ofData", "lazy", "inParallel", "inSequence", "cache", "lift", "trigger", "resolve", "reject"]

    @staticmethod
    def _new(f,lazy = None):
        if (lazy is None):
            lazy = False
        def _hx_local_2(cb):
            def _hx_local_0(v):
                cb(tink_core_Outcome.Success(v))
            def _hx_local_1(e):
                cb(tink_core_Outcome.Failure(e))
            f(_hx_local_0,_hx_local_1)
        this1 = tink_core__Future_Future_Impl_.make(_hx_local_2,lazy)
        return this1

    @staticmethod
    def eager(this1):
        return this1.eager()

    @staticmethod
    def map(this1,f):
        ret = this1.map(f)
        return ret.gather()

    @staticmethod
    def flatMap(this1,f):
        ret = this1.flatMap(f)
        return ret.gather()

    @staticmethod
    def tryRecover(this1,f):
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
            elif (ret1 == 1):
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def recover(this1,f):
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                d = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(d))
            elif (ret1 == 1):
                e = o.params[0]
                return f(e)
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        return ret.gather()

    @staticmethod
    def mapError(this1,f):
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                _g = o.params[0]
                return o
            elif (ret1 == 1):
                e = o.params[0]
                return tink_core_Outcome.Failure(f(e))
            else:
                pass
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def handle(this1,cb):
        return this1.handle(cb)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(v):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def isSuccess(this1):
        def _hx_local_0(o):
            return tink_core_OutcomeTools.isSuccess(o)
        ret = this1.map(_hx_local_0)
        return ret.gather()

    @staticmethod
    def next(this1,f,gather = None):
        if (gather is None):
            gather = True
        gather1 = gather
        if (gather1 is None):
            gather1 = True
        def _hx_local_0(o):
            ret1 = o.index
            if (ret1 == 0):
                d = o.params[0]
                return f(d)
            elif (ret1 == 1):
                f1 = o.params[0]
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(f1)))
            else:
                pass
        ret = this1.flatMap(_hx_local_0)
        if gather1:
            return ret.gather()
        else:
            return ret

    @staticmethod
    def swap(this1,v):
        def _hx_local_1():
            def _hx_local_0(_):
                return v
            return tink_core__Future_Future_Impl_._tryMap(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def swapError(this1,e):
        def _hx_local_1():
            def _hx_local_0(_):
                return e
            return tink_core__Promise_Promise_Impl_.mapError(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def merge(this1,other,merger,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_3():
            def _hx_local_2(t):
                def _hx_local_1():
                    def _hx_local_0(a):
                        return merger(t,a)
                    return tink_core__Promise_Promise_Impl_.next(other,_hx_local_0,False)
                return _hx_local_1()
            return tink_core__Promise_Promise_Impl_.next(this1,_hx_local_2,gather)
        return _hx_local_3()

    @staticmethod
    def _hx_and(a,b):
        def _hx_local_1():
            def _hx_local_0(a1,b1):
                this1 = tink_core_MPair(a1,b1)
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(this1)))
            return tink_core__Promise_Promise_Impl_.merge(a,b,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def iterate(promises,_hx_yield,fallback,lazy = None):
        def _hx_local_4():
            def _hx_local_3(cb):
                _hx_iter = HxOverrides.iterator(promises)
                next = None
                def _hx_local_2():
                    if _hx_iter.hasNext():
                        def _hx_local_1(o):
                            next1 = o.index
                            if (next1 == 0):
                                v = o.params[0]
                                def _hx_local_0(o1):
                                    next2 = o1.index
                                    if (next2 == 0):
                                        _g = o1.params[0]
                                        next3 = _g.index
                                        if (next3 == 0):
                                            ret = _g.params[0]
                                            cb(tink_core_Outcome.Success(ret))
                                        elif (next3 == 1):
                                            next()
                                        else:
                                            pass
                                    elif (next2 == 1):
                                        e = o1.params[0]
                                        cb(tink_core_Outcome.Failure(e))
                                    else:
                                        pass
                                _hx_yield(v).handle(_hx_local_0)
                            elif (next1 == 1):
                                e1 = o.params[0]
                                cb(tink_core_Outcome.Failure(e1))
                            else:
                                pass
                        _hx_iter.next().handle(_hx_local_1)
                    else:
                        fallback.handle(cb)
                next = _hx_local_2
                next()
            return tink_core__Future_Future_Impl_.make(_hx_local_3,lazy)
        return _hx_local_4()

    @staticmethod
    def retry(gen,next):
        def _hx_local_0():
            return (python_lib_Timeit.default_timer() * 1000)
        stamp = _hx_local_0
        start = stamp()
        attempt = None
        def _hx_local_5(count):
            def _hx_local_3(error):
                f1 = (stamp() - start)
                def _hx_local_2():
                    def _hx_local_1(_):
                        return attempt((count + 1))
                    return tink_core__Promise_Promise_Impl_.next(next(_hx_AnonObject({'attempt': count, 'error': error, 'elapsed': f1})),_hx_local_1)
                return _hx_local_2()
            f = _hx_local_3
            def _hx_local_4(o):
                ret1 = o.index
                if (ret1 == 0):
                    d = o.params[0]
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))
                elif (ret1 == 1):
                    e = o.params[0]
                    return f(e)
                else:
                    pass
            ret = gen().flatMap(_hx_local_4)
            return ret.gather()
        attempt = _hx_local_5
        return attempt(1)

    @staticmethod
    def ofSpecific(s):
        return s

    @staticmethod
    def ofFuture(f):
        ret = f.map(tink_core_Outcome.Success)
        return ret.gather()

    @staticmethod
    def ofOutcome(o):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(o))

    @staticmethod
    def ofError(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))

    @staticmethod
    def ofData(d):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))

    @staticmethod
    def lazy(p):
        def _hx_local_1():
            def _hx_local_0(cb):
                p.get().handle(cb)
            return tink_core__Future_Future_Impl_.make(_hx_local_0,True)
        return _hx_local_1()

    @staticmethod
    def inParallel(a,concurrency = None,lazy = None):
        if (len(a) == 0):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
        else:
            def _hx_local_10():
                def _hx_local_9(cb):
                    nonlocal concurrency
                    result = []
                    pending = len(a)
                    links = None
                    linkArray = []
                    sync = False
                    i = 0
                    _hx_iter = python_HaxeIterator(a.__iter__())
                    next = None
                    def _hx_local_0(o):
                        nonlocal sync
                        if (links is None):
                            sync = True
                        elif (links is not None):
                            links.cancel()
                        cb(o)
                    done = _hx_local_0
                    def _hx_local_1(e):
                        nonlocal pending
                        pending = 0
                        done(tink_core_Outcome.Failure(e))
                    fail = _hx_local_1
                    def _hx_local_4(index,value):
                        python_internal_ArrayImpl._set(result, index, value)
                        def _hx_local_3():
                            nonlocal pending
                            pending = (pending - 1)
                            return pending
                        if ((_hx_local_3()) == 0):
                            done(tink_core_Outcome.Success(result))
                        elif (_hx_iter.hasNext() and ((pending > 0))):
                            next()
                    _hx_set = _hx_local_4
                    def _hx_local_7():
                        nonlocal i
                        i = (i + 1)
                        index1 = (i - 1)
                        def _hx_local_6(o1):
                            x1 = o1.index
                            if (x1 == 0):
                                v = o1.params[0]
                                _hx_set(index1,v)
                            elif (x1 == 1):
                                e1 = o1.params[0]
                                fail(e1)
                            else:
                                pass
                        x = _hx_iter.next().handle(_hx_local_6)
                        linkArray.append(x)
                    next = _hx_local_7
                    while True:
                        tmp = None
                        if (_hx_iter.hasNext() and ((pending > 0))):
                            if (concurrency is not None):
                                concurrency = (concurrency - 1)
                                tmp = ((concurrency + 1) > 0)
                            else:
                                tmp = True
                        else:
                            tmp = False
                        if (not tmp):
                            break
                        next()
                    links = tink_core__Callback_CallbackLink_Impl_.fromMany(linkArray)
                    if sync:
                        if (links is not None):
                            links.cancel()
                return tink_core__Future_Future_Impl_.make(_hx_local_9,lazy)
            return _hx_local_10()

    @staticmethod
    def inSequence(a):
        loop = None
        def _hx_local_4(index):
            if (index == len(a)):
                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success([])))
            else:
                def _hx_local_3():
                    def _hx_local_2(head):
                        def _hx_local_1():
                            def _hx_local_0(tail):
                                return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(([head] + tail))))
                            return tink_core__Promise_Promise_Impl_.next(loop((index + 1)),_hx_local_0)
                        return _hx_local_1()
                    return tink_core__Promise_Promise_Impl_.next((a[index] if index >= 0 and index < len(a) else None),_hx_local_2)
                return _hx_local_3()
        loop = _hx_local_4
        return loop(0)

    @staticmethod
    def cache(gen):
        p = None
        def _hx_local_0():
            nonlocal p
            ret = p
            if (ret is None):
                sync = False
                def _hx_local_2(o):
                    def _hx_local_1(_):
                        nonlocal p
                        nonlocal sync
                        sync = True
                        p = None
                    o.b.handle(_hx_local_1)
                    return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(o.a)))
                ret = tink_core__Promise_Promise_Impl_.next(gen(),_hx_local_2)
                if (not sync):
                    p = ret
            def _hx_local_3(o1):
                nonlocal p
                if (not tink_core_OutcomeTools.isSuccess(o1)):
                    p = None
                return o1
            ret1 = ret.map(_hx_local_3)
            return ret1.gather()
        return _hx_local_0

    @staticmethod
    def lift(p):
        return p

    @staticmethod
    def trigger():
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(v):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(v)))

    @staticmethod
    def reject(e):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Failure(e)))


class tink_core__Promise_Next_Impl_:
    _hx_class_name = "tink.core._Promise.Next_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofDynamic", "ofSafe", "ofSync", "ofSafeSync", "_chain"]

    @staticmethod
    def ofDynamic(f):
        def _hx_local_0(x):
            d = f(x)
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(d)))
        return _hx_local_0

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x):
            ret = f(x).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x))))
        return _hx_local_0

    @staticmethod
    def _chain(a,b):
        def _hx_local_0(v):
            return tink_core__Promise_Promise_Impl_.next(a(v),b)
        return _hx_local_0


class tink_core__Promise_Recover_Impl_:
    _hx_class_name = "tink.core._Promise.Recover_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSync"]

    @staticmethod
    def ofSync(f):
        def _hx_local_0(e):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(e)))
        return _hx_local_0


class tink_core__Promise_Combiner_Impl_:
    _hx_class_name = "tink.core._Promise.Combiner_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["ofSafe", "ofSync", "ofSafeSync"]

    @staticmethod
    def ofSafe(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(f(x1,x2)))
        return _hx_local_0

    @staticmethod
    def ofSync(f):
        def _hx_local_0(x1,x2):
            ret = f(x1,x2).map(tink_core_Outcome.Success)
            return ret.gather()
        return _hx_local_0

    @staticmethod
    def ofSafeSync(f):
        def _hx_local_0(x1,x2):
            return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(f(x1,x2))))
        return _hx_local_0


class tink_core__Promise_PromiseTrigger_Impl_:
    _hx_class_name = "tink.core._Promise.PromiseTrigger_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "resolve", "reject", "asPromise"]

    @staticmethod
    def _new():
        this1 = tink_core_FutureTrigger()
        return this1

    @staticmethod
    def resolve(this1,v):
        return this1.trigger(tink_core_Outcome.Success(v))

    @staticmethod
    def reject(this1,e):
        return this1.trigger(tink_core_Outcome.Failure(e))

    @staticmethod
    def asPromise(this1):
        return this1


class tink_core__Ref_Ref_Impl_:
    _hx_class_name = "tink.core._Ref.Ref_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "get_value", "set_value", "toString", "to"]
    value = None

    @staticmethod
    def _new():
        this1 = [None]*1
        this2 = this1
        return this2

    @staticmethod
    def get_value(this1):
        return this1[0]

    @staticmethod
    def set_value(this1,param):
        this1[0] = param
        return param

    @staticmethod
    def toString(this1):
        return (("@[" + Std.string(this1[0])) + "]")

    @staticmethod
    def to(v):
        this1 = [None]*1
        this2 = this1
        ret = this2
        ret[0] = v
        return ret


class tink_core__Signal_Signal_Impl_:
    _hx_class_name = "tink.core._Signal.Signal_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["_new", "map", "flatMap", "filter", "select", "join", "nextTime", "until", "next", "noise", "gather", "generate", "trigger", "create", "ofClassical"]

    @staticmethod
    def _new(f):
        this1 = tink_core__Signal_SimpleSignal(f)
        return this1

    @staticmethod
    def map(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    this3 = f(result)
                    tink_core__Callback_Callback_Impl_.invoke(cb,this3)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def flatMap(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    f(result).handle(cb)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def filter(this1,f,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    if f(result):
                        tink_core__Callback_Callback_Impl_.invoke(cb,result)
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def select(this1,selector,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_1():
                def _hx_local_0(result):
                    _g = selector(result)
                    this3 = _g.index
                    if (this3 == 0):
                        v = _g.params[0]
                        tink_core__Callback_Callback_Impl_.invoke(cb,v)
                    elif (this3 == 1):
                        pass
                    else:
                        pass
                return this1.handle(_hx_local_0)
            return _hx_local_1()
        this2 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def join(this1,other,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_0(cb):
            return tink_core__Callback_LinkPair(this1.handle(cb),other.handle(cb))
        this2 = tink_core__Signal_SimpleSignal(_hx_local_0)
        ret = this2
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret

    @staticmethod
    def nextTime(this1,condition = None):
        ret = tink_core_FutureTrigger()
        link = None
        immediate = False
        def _hx_local_0(v):
            nonlocal immediate
            if ((condition is None) or condition(v)):
                ret.trigger(v)
                if (link is None):
                    immediate = True
                elif (link is not None):
                    link.cancel()
        link = this1.handle(_hx_local_0)
        if immediate:
            if (link is not None):
                link.cancel()
        return ret

    @staticmethod
    def until(this1,end):
        def _hx_local_0(_hx_yield):
            this2 = this1.handle(_hx_yield)
            if (this2 is None):
                return tink_core__Callback_CallbackLink_Impl_.noop
            else:
                return this2.cancel
        ret = tink_core__Signal_Suspendable(_hx_local_0)
        end.handle(tink_core__Callback_Callback_Impl_.fromNiladic(ret.kill))
        return ret

    @staticmethod
    def next(this1,condition = None):
        return tink_core__Signal_Signal_Impl_.nextTime(this1,condition)

    @staticmethod
    def noise(this1):
        def _hx_local_1():
            def _hx_local_0(_):
                return tink_core_Noise.Noise
            return tink_core__Signal_Signal_Impl_.map(this1,_hx_local_0)
        return _hx_local_1()

    @staticmethod
    def gather(this1):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        def _hx_local_0(x):
            ret.handlers.invoke(x)
        this1.handle(_hx_local_0)
        return ret

    @staticmethod
    def generate(generator):
        ret = tink_core__Signal_Signal_Impl_.trigger()
        generator(ret.trigger)
        return ret

    @staticmethod
    def trigger():
        return tink_core_SignalTrigger()

    @staticmethod
    def create(create):
        return tink_core__Signal_Suspendable(create)

    @staticmethod
    def ofClassical(add,remove,gather = None):
        if (gather is None):
            gather = True
        def _hx_local_2(cb):
            def _hx_local_0(a):
                tink_core__Callback_Callback_Impl_.invoke(cb,a)
            f = _hx_local_0
            add(f)
            f1 = remove
            a1 = f
            def _hx_local_1():
                f1(a1)
            this2 = tink_core_SimpleLink(_hx_local_1)
            return this2
        this1 = tink_core__Signal_SimpleSignal(_hx_local_2)
        ret = this1
        if gather:
            return tink_core__Signal_Signal_Impl_.gather(ret)
        else:
            return ret


class tink_core_SignalObject:
    _hx_class_name = "tink.core.SignalObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["handle"]


class tink_core__Signal_SimpleSignal:
    _hx_class_name = "tink.core._Signal.SimpleSignal"
    _hx_is_interface = "False"
    __slots__ = ("f",)
    _hx_fields = ["f"]
    _hx_methods = ["handle"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,f):
        self.f = f

    def handle(self,cb):
        return self.f(cb)



class tink_core__Signal_Suspendable:
    _hx_class_name = "tink.core._Signal.Suspendable"
    _hx_is_interface = "False"
    __slots__ = ("trigger", "activate", "suspend", "check", "killed")
    _hx_fields = ["trigger", "activate", "suspend", "check", "killed"]
    _hx_methods = ["kill", "handle"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self,activate):
        self.check = None
        self.suspend = None
        self.killed = False
        self.trigger = tink_core_SignalTrigger()
        self.activate = activate

    def kill(self):
        if (not self.killed):
            self.killed = True
            self.trigger = None

    def handle(self,cb):
        _gthis = self
        if self.killed:
            return None
        if (self.trigger.handlers.used == 0):
            self.suspend = self.activate(self.trigger.trigger)
        _this = self.trigger.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        def _hx_local_1():
            if (_gthis.trigger.handlers.used == 0):
                _gthis.suspend()
                _gthis.suspend = None
        this1 = tink_core_SimpleLink(_hx_local_1)
        return tink_core__Callback_LinkPair(node,this1)



class tink_core_SignalTrigger:
    _hx_class_name = "tink.core.SignalTrigger"
    _hx_is_interface = "False"
    __slots__ = ("handlers",)
    _hx_fields = ["handlers"]
    _hx_methods = ["trigger", "getLength", "handle", "clear", "asSignal"]
    _hx_interfaces = [tink_core_SignalObject]

    def __init__(self):
        self.handlers = tink_core_CallbackList()

    def trigger(self,event):
        self.handlers.invoke(event)

    def getLength(self):
        return self.handlers.used

    def handle(self,cb):
        _this = self.handlers
        node = tink_core__Callback_ListCell(cb,_this)
        _this1 = _this.cells
        _this1.append(node)
        _this.used = (_this.used + 1)
        return node

    def clear(self):
        self.handlers.clear()

    def asSignal(self):
        return self



class tink_io_WorkerObject:
    _hx_class_name = "tink.io.WorkerObject"
    _hx_is_interface = "True"
    __slots__ = ()
    _hx_methods = ["work"]


class tink_io__Worker_EagerWorker:
    _hx_class_name = "tink.io._Worker.EagerWorker"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_methods = ["work"]
    _hx_interfaces = [tink_io_WorkerObject]

    def __init__(self):
        pass

    def work(self,task):
        return tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(task.get()))



class tink_io__Worker_Worker_Impl_:
    _hx_class_name = "tink.io._Worker.Worker_Impl_"
    _hx_is_interface = "False"
    __slots__ = ()
    _hx_statics = ["EAGER", "pool", "ensure", "get", "work"]

    @staticmethod
    def ensure(this1):
        if (this1 is None):
            return tink_io__Worker_Worker_Impl_.get()
        else:
            return this1

    @staticmethod
    def get():
        x = len(tink_io__Worker_Worker_Impl_.pool)
        return python_internal_ArrayImpl._get(tink_io__Worker_Worker_Impl_.pool, (0 if ((x <= 0)) else int((python_lib_Random.random() * x))))

    @staticmethod
    def work(this1,task):
        return this1.work(task)

Math.NEGATIVE_INFINITY = float("-inf")
Math.POSITIVE_INFINITY = float("inf")
Math.NaN = float("nan")
Math.PI = python_lib_Math.pi

haxe_EntryPoint.pending = list()
haxe_EntryPoint.threadCount = 0
python_Boot.keywords = set(["and", "del", "from", "not", "with", "as", "elif", "global", "or", "yield", "assert", "else", "if", "pass", "None", "break", "except", "import", "raise", "True", "class", "exec", "in", "return", "False", "continue", "finally", "is", "try", "def", "for", "lambda", "while"])
python_Boot.prefixLength = len("_hx_")
python_Lib.lineEnd = ("\r\n" if ((Sys.systemName() == "Windows")) else "\n")
tink__Stringly_Stringly_Impl_.SUPPORTED_DATE_REGEX = EReg("^(\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2})(\\.\\d{3})?(Z|[\\+-]\\d{2}:\\d{2})$","")
tink_core__Callback_Callback_Impl_.depth = 0
tink_core__Callback_Callback_Impl_.MAX_DEPTH = 200
tink_core__Future_NeverFuture.inst = tink_core__Future_NeverFuture()
tink_core__Future_Future_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(None))
tink_core__Future_Future_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Noise.Noise))
tink_core__Future_Future_Impl_.NEVER = tink_core__Future_NeverFuture.inst
tink_core__Lazy_Lazy_Impl_.NULL = tink_core__Lazy_LazyConst(None)
tink_core__Promise_Promise_Impl_.NULL = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(None)))
tink_core__Promise_Promise_Impl_.NOISE = tink_core__Future_SyncFuture(tink_core__Lazy_LazyConst(tink_core_Outcome.Success(tink_core_Noise.Noise)))
def _hx_init_tink_core__Promise_Promise_Impl__NEVER():
    def _hx_local_0():
        ret = tink_core__Future_Future_Impl_.NEVER.map(tink_core_Outcome.Success)
        return ret.gather()
    return _hx_local_0()
tink_core__Promise_Promise_Impl_.NEVER = _hx_init_tink_core__Promise_Promise_Impl__NEVER()
tink_io__Worker_Worker_Impl_.EAGER = tink_io__Worker_EagerWorker()
tink_io__Worker_Worker_Impl_.pool = [tink_io__Worker_Worker_Impl_.EAGER]

hxmake_HxMake.main()
haxe_EntryPoint.run()
